<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Data.Table 教程 on 行行重行行</title>
    <link>http://youngspring1.github.io/categories/data/index.table-%E6%95%99%E7%A8%8B/</link>
    <description>Recent content in Data.Table 教程 on 行行重行行</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>Copyright (c) 2016. All rights reserved.</copyright>
    <lastBuildDate>Sat, 02 Apr 2016 07:38:11 +0800</lastBuildDate>
    <atom:link href="http://youngspring1.github.io/categories/data.table-%E6%95%99%E7%A8%8B/feed/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>data.table 教程4（校对中）</title>
      <link>http://youngspring1.github.io/post/2016-04-02-datatable4/</link>
      <pubDate>Sat, 02 Apr 2016 07:38:11 +0800</pubDate>
      
      <guid>http://youngspring1.github.io/post/2016-04-02-datatable4/</guid>
      <description>

&lt;p&gt;目录：&lt;br /&gt;
1) &lt;a href=&#34;http://youngspring1.github.io/post/2016-03-13-datatable1/&#34;&gt;data.table 介绍&lt;/a&gt;&lt;br /&gt;
2) &lt;a href=&#34;http://youngspring1.github.io/post/2016-03-21-datatable2/&#34;&gt;语义引用&lt;/a&gt;&lt;br /&gt;
3) &lt;a href=&#34;http://youngspring1.github.io/post/2016-03-22-datatable3/&#34;&gt;主键、基于快速二分法搜索的subset&lt;/a&gt;&lt;br /&gt;
4) 二级索引和自动索引&lt;br /&gt;
5) Efficient reshaping using data.tables&lt;/p&gt;

&lt;p&gt;原文地址：&lt;br /&gt;
1) &lt;a href=&#34;https://rawgit.com/wiki/Rdatatable/data.table/vignettes/datatable-intro-vignette.html&#34;&gt;Introduction to data.table&lt;/a&gt;&lt;br /&gt;
2) &lt;a href=&#34;https://rawgit.com/wiki/Rdatatable/data.table/vignettes/datatable-reference-semantics.html&#34;&gt;Reference semantics&lt;/a&gt;&lt;br /&gt;
3) &lt;a href=&#34;https://rawgit.com/wiki/Rdatatable/data.table/vignettes/datatable-keys-fast-subset.html&#34;&gt;Keys and fast binary search based subsets&lt;/a&gt;&lt;br /&gt;
4) &lt;a href=&#34;https://rawgit.com/wiki/Rdatatable/data.table/vignettes/datatable-secondary-indices-and-auto-indexing.html&#34;&gt;Secondary indices and auto indexing&lt;/a&gt;&lt;br /&gt;
5) &lt;a href=&#34;https://rawgit.com/wiki/Rdatatable/data.table/vignettes/datatable-reshape.html&#34;&gt;Efficient reshaping using data.tables&lt;/a&gt;&lt;br /&gt;
6) &lt;a href=&#34;https://rawgit.com/wiki/Rdatatable/data.table/vignettes/datatable-faq.html&#34;&gt;Frequently asked questions&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;本教程假定读者已经熟悉data.table的[i, j, by]语法、懂得如何基于二分法的选取了。如果你对这些不熟悉，请学习上面三讲 &lt;a href=&#34;http://youngspring1.github.io/post/2016-03-13-datatable1/&#34;&gt;data.table 介绍&lt;/a&gt; 、 &lt;a href=&#34;http://youngspring1.github.io/post/2016-03-21-datatable2/&#34;&gt;语义引用&lt;/a&gt;和&lt;a href=&#34;http://youngspring1.github.io/post/2016-03-22-datatable3/&#34;&gt;主键、基于快速二分法搜索的subset&lt;/a&gt;。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;数据:3887792cd19298be3383c54afb194a11&#34;&gt;数据&lt;/h2&gt;

&lt;p&gt;我们继续使用已经保存到本地的航班信息flights。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flights &amp;lt;- fread(&amp;quot;flights14.csv&amp;quot;)
head(flights)
#    year month day dep_delay arr_delay carrier origin dest air_time distance hour
# 1: 2014     1   1        14        13      AA    JFK  LAX      359     2475    9
# 2: 2014     1   1        -3        13      AA    JFK  LAX      363     2475   11
# 3: 2014     1   1         2         9      AA    JFK  LAX      351     2475   19
# 4: 2014     1   1        -8       -26      AA    LGA  PBI      157     1035    7
# 5: 2014     1   1         2         1      AA    JFK  LAX      350     2475   13
# 6: 2014     1   1         4         0      AA    EWR  LAX      339     2454   18
dim(flights)
# [1] 253316     11
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;介绍:3887792cd19298be3383c54afb194a11&#34;&gt;介绍&lt;/h2&gt;

&lt;p&gt;在这一讲，我们会：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;讨论二级索引。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;再次演示快速subset，但这次我们使用新的参数on，它能自动设置二级索引。&lt;/li&gt;
&lt;li&gt;最后进一步的，来看一下自动索引，它也能自动设置索引，但是它是基于R的原生语法来做subset的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;1-二级索引:3887792cd19298be3383c54afb194a11&#34;&gt;1.二级索引&lt;/h2&gt;

&lt;h4 id=&#34;a-什么是二级索引:3887792cd19298be3383c54afb194a11&#34;&gt;a) 什么是二级索引&lt;/h4&gt;

&lt;p&gt;二级索引和data.table的主键类似，但有以下两点不同：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;它不会再内存里将整个data.table重新排序。它只会计算某列的顺序，将这个顺序向量保存在一个额外的，叫做index的属性里面。&lt;/li&gt;
&lt;li&gt;一个data.table可以有多个二级索引，这是我们下面要演示的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;b-设置和获取二级索引:3887792cd19298be3383c54afb194a11&#34;&gt;b) 设置和获取二级索引&lt;/h4&gt;

&lt;p&gt;－如何将origin列设置为该data.table的二级索引&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;setindex(flights, origin)
head(flights)
#    year month day dep_delay arr_delay carrier origin dest air_time distance hour
# 1: 2014     1   1        14        13      AA    JFK  LAX      359     2475    9
# 2: 2014     1   1        -3        13      AA    JFK  LAX      363     2475   11
# 3: 2014     1   1         2         9      AA    JFK  LAX      351     2475   19
# 4: 2014     1   1        -8       -26      AA    LGA  PBI      157     1035    7
# 5: 2014     1   1         2         1      AA    JFK  LAX      350     2475   13
# 6: 2014     1   1         4         0      AA    EWR  LAX      339     2454   18

## alternatively we can provide character vectors to the function &#39;setindexv()&#39;
# setindexv(flights, &amp;quot;origin&amp;quot;) # useful to program with

# &#39;index&#39; attribute added
names(attributes(flights))
# [1] &amp;quot;names&amp;quot;             &amp;quot;row.names&amp;quot;         &amp;quot;class&amp;quot;             &amp;quot;.internal.selfref&amp;quot;
# [5] &amp;quot;index&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;函数setindex 和 setindexv()可以对data.table添加一个二级索引。&lt;/li&gt;
&lt;li&gt;注意flights实际上没有按照origin列的升序重新排列。还记得吗？setkey()会重新排序！&lt;/li&gt;
&lt;li&gt;setindex(flights, NULL)会删除所有的二级索引。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;－如何取得flights的二级索引&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;indices(flights)
# [1] &amp;quot;origin&amp;quot;

setindex(flights, origin, dest)
indices(flights)
# [1] &amp;quot;origin&amp;quot;       &amp;quot;origin__dest&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;函数indices()返回一个data.table所有的二级索引。如果该data.table没有二级索引，那么返回NULL。&lt;/li&gt;
&lt;li&gt;注意我们对 origin列,dest列创建了另一个二级索引的时候，我们没有丢掉之前创建的第一个二级索引。也就是说，我们可以创建多个二级索引。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;c-为什么使用二级索引:3887792cd19298be3383c54afb194a11&#34;&gt;c) 为什么使用二级索引&lt;/h4&gt;

&lt;p&gt;－对一个data.table重新排序成本太高
考虑一下这种情况，当你想用主键origin列来subset所有“JFK”的时候，我们得这么做：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;## not run
setkey(flights, origin)
flights[&amp;quot;JFK&amp;quot;] # or flights[.(&amp;quot;JFK&amp;quot;)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;setkey()需要：
a.计算得出origin列的排序向量，并且
b.基于刚刚的排序向量，对整个data.table重新排序
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;排序并不是最花时间的，因为data.table使用对整型、字符型、数值型的向量进行radix排序。然而重新排序却很花时间。&lt;br /&gt;
除非我们需要对某一列重复地进行subset，否则二分法快速subset的高效可能被重新排序抵消。&lt;/p&gt;

&lt;p&gt;－为添加／更新列而对整个data.table重新排序并不理想&lt;br /&gt;
－最多只能有一个主键&lt;br /&gt;
现在我们如果想对dest列是“LAX”的行，重复地进行某个特定的操作，那么我们必须再调用函数setkey() 设置一次主键。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;## not run
setkey(flights, dest)
flights[&amp;quot;LAX&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，flights又再次按dest列重新排序了。其实我们真正想做的是，快速地subset同时又不必重新排序。&lt;br /&gt;
这时候，二级索引就派上用场了！&lt;/p&gt;

&lt;p&gt;－二级索引可以被重用&lt;br /&gt;
既然一个data.table中可以有多个二级索引，并且创建一个二级索引就和将一个排序向量保存为属性一样简单，那么创建二级索引后，我们可以省下重新排序的时间。&lt;br /&gt;
－参数on使得语法更简洁，并且能自动创建并重用二级索引&lt;br /&gt;
我们下面一节会说明参数on的几个优点：&lt;/p&gt;

&lt;p&gt;参数on&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;通过创建索引进行subset。每次都能节省setindex()的时间。&lt;/li&gt;
&lt;li&gt;通过检查属性，可以简单地重用已经存在的二级索引。&lt;/li&gt;
&lt;li&gt;语法简单。
注意参数on也可以用来指定主键。事实上，为了更佳的可读性，我们鼓励在参数on里面指定主键。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2-使用参数on和索引进行快速subset:3887792cd19298be3383c54afb194a11&#34;&gt;2.使用参数on和索引进行快速subset&lt;/h2&gt;

&lt;h4 id=&#34;a-参数i里的subset:3887792cd19298be3383c54afb194a11&#34;&gt;a) 参数i里的subset&lt;/h4&gt;

&lt;p&gt;－subset所有origin是“JFK”的行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flights[&amp;quot;JFK&amp;quot;, on = &amp;quot;origin&amp;quot;]
#        year month day dep_delay arr_delay carrier origin dest air_time distance hour
#     1: 2014     1   1        14        13      AA    JFK  LAX      359     2475    9
#     2: 2014     1   1        -3        13      AA    JFK  LAX      363     2475   11
#     3: 2014     1   1         2         9      AA    JFK  LAX      351     2475   19
#     4: 2014     1   1         2         1      AA    JFK  LAX      350     2475   13
#     5: 2014     1   1        -2       -18      AA    JFK  LAX      338     2475   21
#    ---
# 81479: 2014    10  31        -4       -21      UA    JFK  SFO      337     2586   17
# 81480: 2014    10  31        -2       -37      UA    JFK  SFO      344     2586   18
# 81481: 2014    10  31         0       -33      UA    JFK  LAX      320     2475   17
# 81482: 2014    10  31        -6       -38      UA    JFK  SFO      343     2586    9
# 81483: 2014    10  31        -6       -38      UA    JFK  LAX      323     2475   11

## alternatively
# flights[.(&amp;quot;JFK&amp;quot;), on = &amp;quot;origin&amp;quot;] (or) 
# flights[list(&amp;quot;JFK&amp;quot;), on = &amp;quot;origin&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;这段语句执行的subset也是通过创建二级索引，基于快速二分法搜索的。但记住，它不会把这个二级索引自动创建为data.table的一个属性。当然后面我们也会教你如何将它设置为一个属性。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;如果我们已经添加了一个二级索引了，那么参数on就可以直接使用这个二级索引，而不是再对整个航班信息flights进行计算。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们来看下面 verbose = TRUE 的用法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;setindex(flights, origin)
flights[&amp;quot;JFK&amp;quot;, on = &amp;quot;origin&amp;quot;, verbose = TRUE][1:5]
# names(on) = NULL. Assigning &#39;on&#39; to names(on)&#39; as well.
# Looking for existing (secondary) index... found. Reusing index.
# Starting bmerge ...done in 0 secs
#    year month day dep_delay arr_delay carrier origin dest air_time distance hour
# 1: 2014     1   1        14        13      AA    JFK  LAX      359     2475    9
# 2: 2014     1   1        -3        13      AA    JFK  LAX      363     2475   11
# 3: 2014     1   1         2         9      AA    JFK  LAX      351     2475   19
# 4: 2014     1   1         2         1      AA    JFK  LAX      350     2475   13
# 5: 2014     1   1        -2       -18      AA    JFK  LAX      338     2475   21
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;－如何对origin列和dest列进行subset
举个例子，如果我们想选取所有从“JFK”起飞到达“LAX”的所有航班：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flights[.(&amp;quot;JFK&amp;quot;, &amp;quot;LAX&amp;quot;), on = c(&amp;quot;origin&amp;quot;, &amp;quot;dest&amp;quot;)][1:5]
#    year month day dep_delay arr_delay carrier origin dest air_time distance hour
# 1: 2014     1   1        14        13      AA    JFK  LAX      359     2475    9
# 2: 2014     1   1        -3        13      AA    JFK  LAX      363     2475   11
# 3: 2014     1   1         2         9      AA    JFK  LAX      351     2475   19
# 4: 2014     1   1         2         1      AA    JFK  LAX      350     2475   13
# 5: 2014     1   1        -2       -18      AA    JFK  LAX      338     2475   21
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在参数i里面指定取值，在参数on里面指定列名。参数on必须是一个字符型的向量。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;因为计算索引非常快，所以我们不需要使用setindex()。除非你需要对某一列重复地进行subset操作。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;b-参数j里的select:3887792cd19298be3383c54afb194a11&#34;&gt;b) 参数j里的select&lt;/h4&gt;

&lt;p&gt;下面我们将要讨论的所有操作，跟我们在上一讲里面学习的类似。只是我们现在使用参数on。&lt;br /&gt;
－返回满足条件 origin = &amp;ldquo;LGA&amp;rdquo; and dest = &amp;ldquo;TPA&amp;rdquo;的 arr_delay列的值&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flights[.(&amp;quot;LGA&amp;quot;, &amp;quot;TPA&amp;quot;), .(arr_delay), on = c(&amp;quot;origin&amp;quot;, &amp;quot;dest&amp;quot;)]
#       arr_delay
#    1:         1
#    2:        14
#    3:       -17
#    4:        -4
#    5:       -12
#   ---          
# 1848:        39
# 1849:       -24
# 1850:       -12
# 1851:        21
# 1852:       -11
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;c-chaining:3887792cd19298be3383c54afb194a11&#34;&gt;c) Chaining&lt;/h4&gt;

&lt;p&gt;－在上面的基础上，使用chaining来将结果降序排列&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flights[.(&amp;quot;LGA&amp;quot;, &amp;quot;TPA&amp;quot;), .(arr_delay), on = c(&amp;quot;origin&amp;quot;, &amp;quot;dest&amp;quot;)][order(-arr_delay)]
#       arr_delay
#    1:       486
#    2:       380
#    3:       351
#    4:       318
#    5:       300
#   ---          
# 1848:       -40
# 1849:       -43
# 1850:       -46
# 1851:       -48
# 1852:       -49
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;d-参数j里的计算:3887792cd19298be3383c54afb194a11&#34;&gt;d) 参数j里的计算&lt;/h4&gt;

&lt;p&gt;－找出满足条件 origin = &amp;ldquo;LGA&amp;rdquo; and dest = &amp;ldquo;TPA&amp;rdquo;的 arr_delay列的最大值（航班到达的最长延误时间）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flights[.(&amp;quot;LGA&amp;quot;, &amp;quot;TPA&amp;quot;), max(arr_delay), on = c(&amp;quot;origin&amp;quot;, &amp;quot;dest&amp;quot;)]
# [1] 486
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;e-参数j里使用操作符-进行sub-assign:3887792cd19298be3383c54afb194a11&#34;&gt;e) 参数j里使用操作符&amp;rdquo;:=&amp;ldquo;进行sub-assign&lt;/h4&gt;

&lt;p&gt;在上一讲中，我们学习过了类似的功能。同样地，现在我们看看如何找到在flights里面，hours列所有可能的取值：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# get all &#39;hours&#39; in flights
flights[, sort(unique(hour))]
#  [1]  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，一共有25种不同的取值。但是0点和24点其实是同样的。下面我们把24全部替换成0，但是这次我们使用参数on。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flights[.(24L), hour := 0L, on = &amp;quot;hour&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在我们再来看看24是不是都被替换成0了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flights[, sort(unique(hour))]
#  [1]  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;这真是二级索引的一大优点。以前，只是为了更新一些行的hour列的取值，我们不得不调用函数setkey()将hour列设置为主键，这必须对整个data.table进行重新排序。但是现在，用参数on，原数据的顺序并没有改变，操作反而更快了！而代码还是如此简洁。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;f-通过参数by聚合:3887792cd19298be3383c54afb194a11&#34;&gt;f) 通过参数by聚合&lt;/h4&gt;

&lt;p&gt;－找到每月从“JFK”起飞的航班起飞的最长延误时间，并按照月份排序&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ans &amp;lt;- flights[&amp;quot;JFK&amp;quot;, max(dep_delay), keyby = month, on = &amp;quot;origin&amp;quot;]
head(ans)
#    month   V1
# 1:     1  881
# 2:     2 1014
# 3:     3  920
# 4:     4 1241
# 5:     5  853
# 6:     6  798
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果我们不使用二级索引，也就是不在参数on里面指定，那么我们就必须把origin设置为主键。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;g-参数mult:3887792cd19298be3383c54afb194a11&#34;&gt;g) 参数mult&lt;/h4&gt;

&lt;p&gt;参数mult和上一讲一样。它的默认值是“all”。我们可以选择是第一条还是最后一条符合条件的行被返回。&lt;br /&gt;
－subset满足条件dest ＝ “BOS” 和 “DAY”的第一行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flights[c(&amp;quot;BOS&amp;quot;, &amp;quot;DAY&amp;quot;), on = &amp;quot;dest&amp;quot;, mult = &amp;quot;first&amp;quot;]
#    year month day dep_delay arr_delay carrier origin dest air_time distance hour
# 1: 2014     1   1         3         1      AA    JFK  BOS       39      187   12
# 2: 2014     1   1        25        35      EV    EWR  DAY      102      533   17
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;－subset满足条件 origin ＝ “LGA” 或者 “JFK” 或者 “EWR”，并且 dest ＝ “XNA” 的最后一行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flights[.(c(&amp;quot;LGA&amp;quot;, &amp;quot;JFK&amp;quot;, &amp;quot;EWR&amp;quot;), &amp;quot;XNA&amp;quot;), on = c(&amp;quot;origin&amp;quot;, &amp;quot;dest&amp;quot;), mult = &amp;quot;last&amp;quot;]
#    year month day dep_delay arr_delay carrier origin dest air_time distance hour
# 1: 2014    10  31        -5       -11      MQ    LGA  XNA      165     1147    6
# 2:   NA    NA  NA        NA        NA      NA    JFK  XNA       NA       NA   NA
# 3: 2014    10  31        -2       -25      EV    EWR  XNA      160     1131    6
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;h-参数nomatch:3887792cd19298be3383c54afb194a11&#34;&gt;h) 参数nomatch&lt;/h4&gt;

&lt;p&gt;如果查询语句没有找到任何匹配的数据，通过指定参数nomatch，我们可以选择是返回 NA，还是忽略。&lt;br /&gt;
－在上面这个列子中，忽略没有实际意义的数据&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flights[.(c(&amp;quot;LGA&amp;quot;, &amp;quot;JFK&amp;quot;, &amp;quot;EWR&amp;quot;), &amp;quot;XNA&amp;quot;), mult = &amp;quot;last&amp;quot;, on = c(&amp;quot;origin&amp;quot;, &amp;quot;dest&amp;quot;), nomatch = 0L]
#    year month day dep_delay arr_delay carrier origin dest air_time distance hour
# 1: 2014    10  31        -5       -11      MQ    LGA  XNA      165     1147    6
# 2: 2014    10  31        -2       -25      EV    EWR  XNA      160     1131    6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;没有航班从“JFK”起飞到达“XNA”，所以结果里面，这一行被忽略了。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;3-自动索引:3887792cd19298be3383c54afb194a11&#34;&gt;3.自动索引&lt;/h2&gt;

&lt;p&gt;回顾一下，我们先学习如何通过主键使用快速二分法搜索进行subset。接着，我们学习了使用二级索引，它带来更好的效果，而且语法也更简洁。&lt;br /&gt;
等等，有没有更好的方法？有！优化R的原生语法，使用内置的索引。这样我们毋需使用新的语法，就能得到同样的效果。&lt;br /&gt;
这就是自动索引。&lt;br /&gt;
目前，它只支持操作符 == 和 %in% 。而且只对一列起作用。某一列会被自动创建为索引，并且作为data.table的属性保存起来。这跟参数on不同，参数on会每次创建一个临时索引，所以才会被叫做“二级索引”。&lt;/p&gt;

&lt;p&gt;让我们创建一个极大的data.table来凸显它的优势。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;set.seed(1L)
dt = data.table(x = sample(1e5L, 1e7L, TRUE), y = runif(100L))
print(object.size(dt), units = &amp;quot;Mb&amp;quot;)
# 114.4 Mb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当我们第一次对某一列使用 == 或者 %in% 的时候，会自动创建一个二级索引，它会被用来进行subset。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# have a look at all the attribute names
names(attributes(dt))
# [1] &amp;quot;names&amp;quot;             &amp;quot;row.names&amp;quot;         &amp;quot;class&amp;quot;             &amp;quot;.internal.selfref&amp;quot;

## run thefirst time
(t1 &amp;lt;- system.time(ans &amp;lt;- dt[x == 989L]))
#    user  system elapsed 
#   0.235   0.013   0.249
head(ans)
#      x         y
# 1: 989 0.5372007
# 2: 989 0.5642786
# 3: 989 0.7151100
# 4: 989 0.3920405
# 5: 989 0.9547465
# 6: 989 0.2914710

## secondary index is created
names(attributes(dt))
# [1] &amp;quot;names&amp;quot;             &amp;quot;row.names&amp;quot;         &amp;quot;class&amp;quot;             &amp;quot;.internal.selfref&amp;quot;
# [5] &amp;quot;index&amp;quot;

indices(dt)
# [1] &amp;quot;x&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一次subset的时候，就是创建索引的时候。因为创建二级索引只会引入一个排序向量，在很多情况下，这种操作符的方式会比扫描向量快得多。所以，从第二次subset开始，自动索引的优势就非常明显了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;## successive subsets
(t2 &amp;lt;- system.time(dt[x == 989L]))
#    user  system elapsed 
#   0.001   0.000   0.001
system.time(dt[x %in% 1989:2012])
#    user  system elapsed 
#   0.001   0.000   0.001
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;第一次subset花了0.228秒，但是第二次只花了0.001秒！&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;可以通过设置全局参数关闭自动索引：options(datatable.auto.index = FALSE)。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们正在将二分法搜索扩展到其它的操作符，比如 &amp;lt;, &amp;lt;= 和 &amp;gt;=。完成之后，就能直接用在其他操作符上了。&lt;br /&gt;
在将来，我们计划将自动索引扩展到参数中的其它列。&lt;/p&gt;

&lt;p&gt;在下一讲“结合和滚动结合”中，我们会学习使用主键和二级索引进行快速subset。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>