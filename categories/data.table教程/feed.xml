<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Data.Table教程 on 行行重行行</title>
    <link>http://youngspring1.github.io/categories/data/index.table%E6%95%99%E7%A8%8B/</link>
    <description>Recent content in Data.Table教程 on 行行重行行</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>Copyright (c) 2016. All rights reserved.</copyright>
    <lastBuildDate>Fri, 08 Apr 2016 13:00:57 +0800</lastBuildDate>
    <atom:link href="http://youngspring1.github.io/categories/data.table%E6%95%99%E7%A8%8B/feed/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>data.table 教程5－数据拆分和合并</title>
      <link>http://youngspring1.github.io/post/2016/2016-04-08-datatable5/</link>
      <pubDate>Fri, 08 Apr 2016 13:00:57 +0800</pubDate>
      
      <guid>http://youngspring1.github.io/post/2016/2016-04-08-datatable5/</guid>
      <description>

&lt;p&gt;目录：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://youngspring1.github.io/post/2016/2016-03-13-datatable1/&#34;&gt;data.table 介绍&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://youngspring1.github.io/post/2016/2016-03-21-datatable2/&#34;&gt;语义引用&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://youngspring1.github.io/post/2016/2016-03-22-datatable3/&#34;&gt;主键、基于二分法搜索的subset&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://youngspring1.github.io/post/2016/2016-04-02-datatable4/&#34;&gt;二次索引和自动索引&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://youngspring1.github.io/post/2016/2016-04-08-datatable5/&#34;&gt;数据拆分和合并&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;原文地址：&lt;br /&gt;
&lt;a href=&#34;https://github.com/Rdatatable/data.table/wiki/Getting-started&#34;&gt;data.table/wiki/Getting-started&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;数据拆分和合并:8a0e17190d0dbfa1c06f28f3c1a1fd66&#34;&gt;数据拆分和合并&lt;/h1&gt;

&lt;p&gt;这一讲我们学习reshaping函数 melt 和 dcast 原本的用法，以及从R语言 v1.9.6版以后，函数 melt 和 dcast 新扩展的功能（它们能操作多个列）。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;数据:8a0e17190d0dbfa1c06f28f3c1a1fd66&#34;&gt;数据&lt;/h2&gt;

&lt;p&gt;我们在讲解的时候直接加载数据。&lt;/p&gt;

&lt;h2 id=&#34;介绍:8a0e17190d0dbfa1c06f28f3c1a1fd66&#34;&gt;介绍&lt;/h2&gt;

&lt;p&gt;data.table的函数melt 和 dcast 是增强包&lt;a href=&#34;https://cran.r-project.org/web/packages/reshape2/index.html&#34;&gt;reshape2&lt;/a&gt;里同名函数的扩展。&lt;br /&gt;
在这一讲，我们会：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;首先，简单看一下原先的函数 melt 和 dcast，它们是如何reshaping一个data.table。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;然后，了解一下当前的功能是如何变得冗长而且低效。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;最后，学习一下改进之后的函数 melt 和 dcast 如何同时处理多个列。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;扩展后的功能符合data.table的设计哲学：运行高效，语法简明。&lt;/p&gt;

&lt;p&gt;注意：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;从R语言 v1.9.6版以后，你再也不需要加载增强包 reshape2 了，只需要加载 data.table。如果你已经加载了 reshape2 来处理矩阵或者data.frame，那么一定要确保在这之后再加载 data.table。
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;1-原生的melt-dcast:8a0e17190d0dbfa1c06f28f3c1a1fd66&#34;&gt;1.原生的melt／dcast&lt;/h2&gt;

&lt;h4 id=&#34;a-函数melt:8a0e17190d0dbfa1c06f28f3c1a1fd66&#34;&gt;a) 函数melt&lt;/h4&gt;

&lt;p&gt;假设我们有下面这样的data.table：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DT = fread(&amp;quot;melt_default.csv&amp;quot;)
DT
#    family_id age_mother dob_child1 dob_child2 dob_child3
# 1:         1         30 1998-11-26 2000-01-29         NA
# 2:         2         27 1996-06-22         NA         NA
# 3:         3         26 2002-07-11 2004-04-05 2007-09-02
# 4:         4         32 2004-10-10 2009-08-27 2012-07-21
# 5:         5         29 2000-12-05 2005-02-28         NA
## dob stands for date of birth.

str(DT)
# Classes &#39;data.table&#39; and &#39;data.frame&#39;:    5 obs. of  5 variables:
#  $ family_id : int  1 2 3 4 5
#  $ age_mother: int  30 27 26 32 29
#  $ dob_child1: chr  &amp;quot;1998-11-26&amp;quot; &amp;quot;1996-06-22&amp;quot; &amp;quot;2002-07-11&amp;quot; &amp;quot;2004-10-10&amp;quot; ...
#  $ dob_child2: chr  &amp;quot;2000-01-29&amp;quot; NA &amp;quot;2004-04-05&amp;quot; &amp;quot;2009-08-27&amp;quot; ...
#  $ dob_child3: chr  NA NA &amp;quot;2007-09-02&amp;quot; &amp;quot;2012-07-21&amp;quot; ...
#  - attr(*, &amp;quot;.internal.selfref&amp;quot;)=&amp;lt;externalptr&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;－转化DT，使得每个小孩的出生信息都独占一条数据&lt;br /&gt;
我们可以对函数 melt() 指定参数 id.vars 和 measure.vars 来实现&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DT.m1 = melt(DT, id.vars = c(&amp;quot;family_id&amp;quot;, &amp;quot;age_mother&amp;quot;),
        measure.vars = c(&amp;quot;dob_child1&amp;quot;, &amp;quot;dob_child2&amp;quot;, &amp;quot;dob_child3&amp;quot;))
DT.m1
#     family_id age_mother   variable      value
#  1:         1         30 dob_child1 1998-11-26
#  2:         2         27 dob_child1 1996-06-22
#  3:         3         26 dob_child1 2002-07-11
#  4:         4         32 dob_child1 2004-10-10
#  5:         5         29 dob_child1 2000-12-05
#  6:         1         30 dob_child2 2000-01-29
#  7:         2         27 dob_child2         NA
#  8:         3         26 dob_child2 2004-04-05
#  9:         4         32 dob_child2 2009-08-27
# 10:         5         29 dob_child2 2005-02-28
# 11:         1         30 dob_child3         NA
# 12:         2         27 dob_child3         NA
# 13:         3         26 dob_child3 2007-09-02
# 14:         4         32 dob_child3 2012-07-21
# 15:         5         29 dob_child3         NA
str(DT.m1)
# Classes &#39;data.table&#39; and &#39;data.frame&#39;:    15 obs. of  4 variables:
#  $ family_id : int  1 2 3 4 5 1 2 3 4 5 ...
#  $ age_mother: int  30 27 26 32 29 30 27 26 32 29 ...
#  $ variable  : Factor w/ 3 levels &amp;quot;dob_child1&amp;quot;,&amp;quot;dob_child2&amp;quot;,..: 1 1 1 1 1 2 2 2 2 2 ...
#  $ value     : chr  &amp;quot;1998-11-26&amp;quot; &amp;quot;1996-06-22&amp;quot; &amp;quot;2002-07-11&amp;quot; &amp;quot;2004-10-10&amp;quot; ...
#  - attr(*, &amp;quot;.internal.selfref&amp;quot;)=&amp;lt;externalptr&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;参数 measure.vars 指定了想要拆分（或合并）的列。&lt;/li&gt;
&lt;li&gt;我们也可以指定索引而不是列名。&lt;/li&gt;
&lt;li&gt;默认的，variable列是 factor（因子）类型的。如果你想返回一个字符型的向量，可以将参数 variable.factor 设为 FALSE。参数 variable.factor 是data.table的函数melt() 里独有的，增强包reshape2 里面没有这个参数。&lt;/li&gt;
&lt;li&gt;默认的，转化果的列被自动命名为 variable 和 value。&lt;/li&gt;
&lt;li&gt;在结果里，函数melt() 保持了原来列的属性。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;－分别将 variable列和 value列重命名为 child 和 dob&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DT.m1 = melt(DT, measure.vars = c(&amp;quot;dob_child1&amp;quot;, &amp;quot;dob_child2&amp;quot;, &amp;quot;dob_child3&amp;quot;),
           variable.name = &amp;quot;child&amp;quot;, value.name = &amp;quot;dob&amp;quot;)
DT.m1
#     family_id age_mother      child        dob
#  1:         1         30 dob_child1 1998-11-26
#  2:         2         27 dob_child1 1996-06-22
#  3:         3         26 dob_child1 2002-07-11
#  4:         4         32 dob_child1 2004-10-10
#  5:         5         29 dob_child1 2000-12-05
#  6:         1         30 dob_child2 2000-01-29
#  7:         2         27 dob_child2         NA
#  8:         3         26 dob_child2 2004-04-05
#  9:         4         32 dob_child2 2009-08-27
# 10:         5         29 dob_child2 2005-02-28
# 11:         1         30 dob_child3         NA
# 12:         2         27 dob_child3         NA
# 13:         3         26 dob_child3 2007-09-02
# 14:         4         32 dob_child3 2012-07-21
# 15:         5         29 dob_child3         NA
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;默认的，参数id.vars 或 measure.vars 中的一个省略了，剩余的列自动被赋值给省略的那个参数。&lt;/li&gt;
&lt;li&gt;如果参数id.vars 和 measure.vars 都没有指定，所有不是numberic／integer／logical的列都会被赋值给 id.vars。另外，系统还会输出一条警告消息，提示那些列被认为是 id.vars。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;b-函数cast:8a0e17190d0dbfa1c06f28f3c1a1fd66&#34;&gt;b) 函数cast&lt;/h4&gt;

&lt;p&gt;在前面一节，我们知道如何分拆数据。这一节，我们学习相反的操作。&lt;br /&gt;
－如何将刚刚分拆的 DT.m 还原成 DT&lt;br /&gt;
也就是，我们想把每个家庭／母亲的所有小孩，都合并到同一行里。我们可以像下面这样使用函数 dcast()。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dcast(DT.m1, family_id + age_mother ~ child, value.var = &amp;quot;dob&amp;quot;)
#    family_id age_mother dob_child1 dob_child2 dob_child3
# 1:         1         30 1998-11-26 2000-01-29         NA
# 2:         2         27 1996-06-22         NA         NA
# 3:         3         26 2002-07-11 2004-04-05 2007-09-02
# 4:         4         32 2004-10-10 2009-08-27 2012-07-21
# 5:         5         29 2000-12-05 2005-02-28         NA
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;函数 dcast() 使用了操作符“~”，左边是作为 id.vars 的列，右边是作为 measure.vars 的列。&lt;/li&gt;
&lt;li&gt;参数 value.var 指定了需要被分拆扩张的列。&lt;/li&gt;
&lt;li&gt;函数 dcast() 也会在结果中尽量保持原来的属性。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;－对于 DT.m，如何知道每个家庭有几个小孩&lt;br /&gt;
可以给函数 dcast() 的参数 fun.aggregate 传递一个函数。当操作符“~”不方便指定列名的时候，这个功能特别有用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dcast(DT.m1, family_id ~ ., fun.agg = function(x) sum(!is.na(x)), value.var = &amp;quot;dob&amp;quot;)
#    family_id .
# 1:         1 2
# 2:         2 1
# 3:         3 3
# 4:         4 3
# 5:         5 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输入 ?dcast 可以查看其他参数和例子的说明。&lt;/p&gt;

&lt;h2 id=&#34;2-原生的melt-dcast的局限:8a0e17190d0dbfa1c06f28f3c1a1fd66&#34;&gt;2.原生的melt／dcast的局限&lt;/h2&gt;

&lt;p&gt;到目前为止，我们学习了函数 melt 和 dcast 的功能，它们是基于增强包 reshape2 的。但是因为使用了data.table的内部机制（快速排序，二分法搜索等），所以能有效地对data.table实行。&lt;br /&gt;
然而，也有一些情况，我们想做的操作无法写得很简洁。比如，考虑下面这个data.table：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DT = fread(&amp;quot;melt_enhanced.csv&amp;quot;)
DT
#    family_id age_mother dob_child1 dob_child2 dob_child3 gender_child1 gender_child2 gender_child3
# 1:         1         30 1998-11-26 2000-01-29         NA             1             2            NA
# 2:         2         27 1996-06-22         NA         NA             2            NA            NA
# 3:         3         26 2002-07-11 2004-04-05 2007-09-02             2             2             1
# 4:         4         32 2004-10-10 2009-08-27 2012-07-21             1             1             1
# 5:         5         29 2000-12-05 2005-02-28         NA             2             1            NA
## 1 = female, 2 = male
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你想用我们到目前为止学过的知识，将每个孩子的 dob 和 gender 合并到一行中，得这样做：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DT.m1 = melt(DT, id = c(&amp;quot;family_id&amp;quot;, &amp;quot;age_mother&amp;quot;))
# Warning in melt.data.table(DT, id = c(&amp;quot;family_id&amp;quot;, &amp;quot;age_mother&amp;quot;)): &#39;measure.vars&#39; [dob_child1,
# dob_child2, dob_child3, gender_child1, gender_child2, gender_child3] are not all of the same
# type. By order of hierarchy, the molten data value column will be of type &#39;character&#39;. All measure
# variables not of type &#39;character&#39; will be coerced to. Check DETAILS in ?melt.data.table for more on
# coercion.
DT.m1[, c(&amp;quot;variable&amp;quot;, &amp;quot;child&amp;quot;) := tstrsplit(variable, &amp;quot;_&amp;quot;, fixed = TRUE)]
DT.c1 = dcast(DT.m1, family_id + age_mother + child ~ variable, value.var = &amp;quot;value&amp;quot;)
DT.c1
#     family_id age_mother  child        dob gender
#  1:         1         30 child1 1998-11-26      1
#  2:         1         30 child2 2000-01-29      2
#  3:         1         30 child3         NA     NA
#  4:         2         27 child1 1996-06-22      2
#  5:         2         27 child2         NA     NA
#  6:         2         27 child3         NA     NA
#  7:         3         26 child1 2002-07-11      2
#  8:         3         26 child2 2004-04-05      2
#  9:         3         26 child3 2007-09-02      1
# 10:         4         32 child1 2004-10-10      1
# 11:         4         32 child2 2009-08-27      1
# 12:         4         32 child3 2012-07-21      1
# 13:         5         29 child1 2000-12-05      2
# 14:         5         29 child2 2005-02-28      1
# 15:         5         29 child3         NA     NA

str(DT.c1) ## gender column is character type now!
# Classes &#39;data.table&#39; and &#39;data.frame&#39;:    15 obs. of  5 variables:
#  $ family_id : int  1 1 1 2 2 2 3 3 3 4 ...
#  $ age_mother: int  30 30 30 27 27 27 26 26 26 32 ...
#  $ child     : chr  &amp;quot;child1&amp;quot; &amp;quot;child2&amp;quot; &amp;quot;child3&amp;quot; &amp;quot;child1&amp;quot; ...
#  $ dob       : chr  &amp;quot;1998-11-26&amp;quot; &amp;quot;2000-01-29&amp;quot; NA &amp;quot;1996-06-22&amp;quot; ...
#  $ gender    : chr  &amp;quot;1&amp;quot; &amp;quot;2&amp;quot; NA &amp;quot;2&amp;quot; ...
#  - attr(*, &amp;quot;.internal.selfref&amp;quot;)=&amp;lt;externalptr&amp;gt; 
#  - attr(*, &amp;quot;sorted&amp;quot;)= chr  &amp;quot;family_id&amp;quot; &amp;quot;age_mother&amp;quot; &amp;quot;child&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;问题：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;我们想做的是，分别将每个孩子的 dob 和 gender 合并到一行。但是我们先把所有的东西都拆分开了，再将它们合并。很容易看出，这太过迂回和低效了。
类似的，想想你的壁橱里有4架子的衣服，你想把第1架和第2架的衣服全都放到第1架上，把第3架和第4架的衣服全都放到第3架上。我们刚刚做的事情，就像把4架衣服都放一起，再分开放到第1架和第3架上！&lt;/li&gt;
&lt;li&gt;需要被整合的列可能是不同的类型，在这个例子里面，是字符型和整型。使用函数melt 的时候，这些列被硬塞到结果里面，正如str(DT.c1)的警告消息所提示的，gender列被转化成了字符型。&lt;/li&gt;
&lt;li&gt;我们将variable拆分成了两列，因此额外多了一列，这样做的目的真是非常模糊。我们这么做是因为下一步我们需要转化这一列。&lt;/li&gt;
&lt;li&gt;最后，我们整合了数据。但是问题是我们引入很多操作。特别是，必须要计算等式中变量的顺序，代价太大。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;事实上，base::reshape 有简单的写法来实现这个操作。它非常有用，而且经常被低估。你应该试试！&lt;/p&gt;

&lt;h2 id=&#34;3-增强的新功能:8a0e17190d0dbfa1c06f28f3c1a1fd66&#34;&gt;3.增强的新功能&lt;/h2&gt;

&lt;h4 id=&#34;a-增强的melt:8a0e17190d0dbfa1c06f28f3c1a1fd66&#34;&gt;a) 增强的melt&lt;/h4&gt;

&lt;p&gt;既然我们希望简单地实现同样的操作，我们实现了一个额外的功能，这样就可以同时操作多个列。&lt;br /&gt;
－用函数melt 同时拆分多个列&lt;br /&gt;
这个办法很简单。我们给参数 measure.vars 传递一个列表，这个列表的每个元素包含需要被合并的列。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;colA = paste(&amp;quot;dob_child&amp;quot;, 1:3, sep = &amp;quot;&amp;quot;)
colB = paste(&amp;quot;gender_child&amp;quot;, 1:3, sep = &amp;quot;&amp;quot;)
DT.m2 = melt(DT, measure = list(colA, colB), value.name = c(&amp;quot;dob&amp;quot;, &amp;quot;gender&amp;quot;))
DT.m2
#     family_id age_mother variable        dob gender
#  1:         1         30        1 1998-11-26      1
#  2:         2         27        1 1996-06-22      2
#  3:         3         26        1 2002-07-11      2
#  4:         4         32        1 2004-10-10      1
#  5:         5         29        1 2000-12-05      2
#  6:         1         30        2 2000-01-29      2
#  7:         2         27        2         NA     NA
#  8:         3         26        2 2004-04-05      2
#  9:         4         32        2 2009-08-27      1
# 10:         5         29        2 2005-02-28      1
# 11:         1         30        3         NA     NA
# 12:         2         27        3         NA     NA
# 13:         3         26        3 2007-09-02      1
# 14:         4         32        3 2012-07-21      1
# 15:         5         29        3         NA     NA

str(DT.m2) ## col type is preserved
# Classes &#39;data.table&#39; and &#39;data.frame&#39;:    15 obs. of  5 variables:
#  $ family_id : int  1 2 3 4 5 1 2 3 4 5 ...
#  $ age_mother: int  30 27 26 32 29 30 27 26 32 29 ...
#  $ variable  : Factor w/ 3 levels &amp;quot;1&amp;quot;,&amp;quot;2&amp;quot;,&amp;quot;3&amp;quot;: 1 1 1 1 1 2 2 2 2 2 ...
#  $ dob       : chr  &amp;quot;1998-11-26&amp;quot; &amp;quot;1996-06-22&amp;quot; &amp;quot;2002-07-11&amp;quot; &amp;quot;2004-10-10&amp;quot; ...
#  $ gender    : int  1 2 2 1 2 2 NA 2 1 1 ...
#  - attr(*, &amp;quot;.internal.selfref&amp;quot;)=&amp;lt;externalptr&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;－函数 patterns()&lt;br /&gt;
通常，我们想整合的这些列的列名都有共通的格式。我们可以用函数patterns()指定正则表达式，让语法更简洁。上面的操作还可以这样写：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DT.m2 = melt(DT, measure = patterns(&amp;quot;^dob&amp;quot;, &amp;quot;^gender&amp;quot;), value.name = c(&amp;quot;dob&amp;quot;, &amp;quot;gender&amp;quot;))
DT.m2
#     family_id age_mother variable        dob gender
#  1:         1         30        1 1998-11-26      1
#  2:         2         27        1 1996-06-22      2
#  3:         3         26        1 2002-07-11      2
#  4:         4         32        1 2004-10-10      1
#  5:         5         29        1 2000-12-05      2
#  6:         1         30        2 2000-01-29      2
#  7:         2         27        2         NA     NA
#  8:         3         26        2 2004-04-05      2
#  9:         4         32        2 2009-08-27      1
# 10:         5         29        2 2005-02-28      1
# 11:         1         30        3         NA     NA
# 12:         2         27        3         NA     NA
# 13:         3         26        3 2007-09-02      1
# 14:         4         32        3 2012-07-21      1
# 15:         5         29        3         NA     NA
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就是这样！&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果需要，我们可以去掉 variable列。&lt;/li&gt;
&lt;li&gt;这个功能是用C实现的，因此效率高，节省内存，而且简洁。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;b-增强的dcast:8a0e17190d0dbfa1c06f28f3c1a1fd66&#34;&gt;b) 增强的dcast&lt;/h4&gt;

&lt;p&gt;非常好！现在我们可以同时拆分多个列了。现在我们如何将上面的 DT.m2 再恢复成原来的样子呢？&lt;br /&gt;
如果我们使用原生的函数dcast()，我们需要做两次，然后将结果合并在一起。但是这样做太麻烦，一点也不简洁和有效。&lt;br /&gt;
－同时合并多个 value.vars&lt;br /&gt;
我们可以对函数dcast()指定多个 value.var参数，这样操作就在内部进行，而且高效。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;## new &#39;cast&#39; functionality - multiple value.vars
DT.c2 = dcast(DT.m2, family_id + age_mother ~ variable, value.var = c(&amp;quot;dob&amp;quot;, &amp;quot;gender&amp;quot;))
DT.c2
#    family_id age_mother      dob_1      dob_2      dob_3 gender_1 gender_2 gender_3
# 1:         1         30 1998-11-26 2000-01-29         NA        1        2       NA
# 2:         2         27 1996-06-22         NA         NA        2       NA       NA
# 3:         3         26 2002-07-11 2004-04-05 2007-09-02        2        2        1
# 4:         4         32 2004-10-10 2009-08-27 2012-07-21        1        1        1
# 5:         5         29 2000-12-05 2005-02-28         NA        2        1       NA
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在结果中，原先的属性会尽量保持。&lt;/li&gt;
&lt;li&gt;所有的事情都在内部高效处理。快速并且节省内存。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参数fun.aggregate可以指定多个函数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;你可以给函数dcast()的参数fun.aggregate可以指定多个函数。详细内容请执行 ?dcast 来查看示例。
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>data.table 教程4－二级索引和自动索引</title>
      <link>http://youngspring1.github.io/post/2016/2016-04-02-datatable4/</link>
      <pubDate>Sat, 02 Apr 2016 07:38:11 +0800</pubDate>
      
      <guid>http://youngspring1.github.io/post/2016/2016-04-02-datatable4/</guid>
      <description>

&lt;p&gt;目录：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://youngspring1.github.io/post/2016/2016-03-13-datatable1/&#34;&gt;data.table 介绍&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://youngspring1.github.io/post/2016/2016-03-21-datatable2/&#34;&gt;语义引用&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://youngspring1.github.io/post/2016/2016-03-22-datatable3/&#34;&gt;主键、基于二分法搜索的subset&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://youngspring1.github.io/post/2016/2016-04-02-datatable4/&#34;&gt;二次索引和自动索引&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://youngspring1.github.io/post/2016/2016-04-08-datatable5/&#34;&gt;数据拆分和合并&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;原文地址：&lt;br /&gt;
&lt;a href=&#34;https://github.com/Rdatatable/data.table/wiki/Getting-started&#34;&gt;data.table/wiki/Getting-started&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;感谢&lt;a href=&#34;http://weibo.com/u/2120911240&#34;&gt;G_天星&lt;/a&gt;的提醒，貌似现在版本的data.table中还没有setindex()函数，所以可能应该使用set2key()函数。或者通过代码安装data.table试试。&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;二级索引和自动索引:3887792cd19298be3383c54afb194a11&#34;&gt;二级索引和自动索引&lt;/h1&gt;

&lt;p&gt;本教程假定读者已经熟悉data.table的[i, j, by]语法、懂得如何基于二分法的选取了。如果你对这些不熟悉，请学习上面三讲 &lt;a href=&#34;http://youngspring1.github.io/post/2016-03-13-datatable1/&#34;&gt;data.table 介绍&lt;/a&gt; 、 &lt;a href=&#34;http://youngspring1.github.io/post/2016-03-21-datatable2/&#34;&gt;语义引用&lt;/a&gt;和&lt;a href=&#34;http://youngspring1.github.io/post/2016-03-22-datatable3/&#34;&gt;主键、基于快速二分法搜索的subset&lt;/a&gt;。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;数据:3887792cd19298be3383c54afb194a11&#34;&gt;数据&lt;/h2&gt;

&lt;p&gt;我们继续使用已经保存到本地的航班信息flights。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flights &amp;lt;- fread(&amp;quot;flights14.csv&amp;quot;)
head(flights)
#    year month day dep_delay arr_delay carrier origin dest air_time distance hour
# 1: 2014     1   1        14        13      AA    JFK  LAX      359     2475    9
# 2: 2014     1   1        -3        13      AA    JFK  LAX      363     2475   11
# 3: 2014     1   1         2         9      AA    JFK  LAX      351     2475   19
# 4: 2014     1   1        -8       -26      AA    LGA  PBI      157     1035    7
# 5: 2014     1   1         2         1      AA    JFK  LAX      350     2475   13
# 6: 2014     1   1         4         0      AA    EWR  LAX      339     2454   18
dim(flights)
# [1] 253316     11
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;介绍:3887792cd19298be3383c54afb194a11&#34;&gt;介绍&lt;/h2&gt;

&lt;p&gt;在这一讲，我们会：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;讨论二级索引。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;再次演示快速subset，但这次我们使用新的参数on，它能自动设置二级索引。&lt;/li&gt;
&lt;li&gt;最后进一步的，来看一下自动索引，它也能自动设置索引，但是它是基于R的原生语法来做subset的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;1-二级索引:3887792cd19298be3383c54afb194a11&#34;&gt;1.二级索引&lt;/h2&gt;

&lt;h4 id=&#34;a-什么是二级索引:3887792cd19298be3383c54afb194a11&#34;&gt;a) 什么是二级索引&lt;/h4&gt;

&lt;p&gt;二级索引和data.table的主键类似，但有以下两点不同：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;它不会再内存里将整个data.table重新排序。它只会计算某列的顺序，将这个顺序向量保存在一个额外的，叫做index的属性里面。&lt;/li&gt;
&lt;li&gt;一个data.table可以有多个二级索引，这是我们下面要演示的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;b-设置和获取二级索引:3887792cd19298be3383c54afb194a11&#34;&gt;b) 设置和获取二级索引&lt;/h4&gt;

&lt;p&gt;－如何将origin列设置为该data.table的二级索引&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;setindex(flights, origin)
head(flights)
#    year month day dep_delay arr_delay carrier origin dest air_time distance hour
# 1: 2014     1   1        14        13      AA    JFK  LAX      359     2475    9
# 2: 2014     1   1        -3        13      AA    JFK  LAX      363     2475   11
# 3: 2014     1   1         2         9      AA    JFK  LAX      351     2475   19
# 4: 2014     1   1        -8       -26      AA    LGA  PBI      157     1035    7
# 5: 2014     1   1         2         1      AA    JFK  LAX      350     2475   13
# 6: 2014     1   1         4         0      AA    EWR  LAX      339     2454   18

## alternatively we can provide character vectors to the function &#39;setindexv()&#39;
# setindexv(flights, &amp;quot;origin&amp;quot;) # useful to program with

# &#39;index&#39; attribute added
names(attributes(flights))
# [1] &amp;quot;names&amp;quot;             &amp;quot;row.names&amp;quot;         &amp;quot;class&amp;quot;             &amp;quot;.internal.selfref&amp;quot;
# [5] &amp;quot;index&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;函数setindex 和 setindexv()可以对data.table添加一个二级索引。&lt;/li&gt;
&lt;li&gt;注意flights实际上没有按照origin列的升序重新排列。还记得吗？setkey()会重新排序！&lt;/li&gt;
&lt;li&gt;setindex(flights, NULL)会删除所有的二级索引。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;－如何取得flights的二级索引&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;indices(flights)
# [1] &amp;quot;origin&amp;quot;

setindex(flights, origin, dest)
indices(flights)
# [1] &amp;quot;origin&amp;quot;       &amp;quot;origin__dest&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;函数indices()返回一个data.table所有的二级索引。如果该data.table没有二级索引，那么返回NULL。&lt;/li&gt;
&lt;li&gt;注意我们对 origin列,dest列创建了另一个二级索引的时候，我们没有丢掉之前创建的第一个二级索引。也就是说，我们可以创建多个二级索引。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;c-为什么使用二级索引:3887792cd19298be3383c54afb194a11&#34;&gt;c) 为什么使用二级索引&lt;/h4&gt;

&lt;p&gt;－对一个data.table重新排序成本太高
考虑一下这种情况，当你想用主键origin列来subset所有“JFK”的时候，我们得这么做：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;## not run
setkey(flights, origin)
flights[&amp;quot;JFK&amp;quot;] # or flights[.(&amp;quot;JFK&amp;quot;)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;setkey()需要：
a.计算得出origin列的排序向量，并且
b.基于刚刚的排序向量，对整个data.table重新排序
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;排序并不是最花时间的，因为data.table使用对整型、字符型、数值型的向量进行radix排序。然而重新排序却很花时间。&lt;br /&gt;
除非我们需要对某一列重复地进行subset，否则二分法快速subset的高效可能被重新排序抵消。&lt;/p&gt;

&lt;p&gt;－为添加／更新列而对整个data.table重新排序并不理想&lt;br /&gt;
－最多只能有一个主键&lt;br /&gt;
现在我们如果想对dest列是“LAX”的行，重复地进行某个特定的操作，那么我们必须再调用函数setkey() 设置一次主键。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;## not run
setkey(flights, dest)
flights[&amp;quot;LAX&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，flights又再次按dest列重新排序了。其实我们真正想做的是，快速地subset同时又不必重新排序。&lt;br /&gt;
这时候，二级索引就派上用场了！&lt;/p&gt;

&lt;p&gt;－二级索引可以被重用&lt;br /&gt;
既然一个data.table中可以有多个二级索引，并且创建一个二级索引就和将一个排序向量保存为属性一样简单，那么创建二级索引后，我们可以省下重新排序的时间。&lt;br /&gt;
－参数on使得语法更简洁，并且能自动创建并重用二级索引&lt;br /&gt;
我们下面一节会说明参数on的几个优点：&lt;/p&gt;

&lt;p&gt;参数on&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;通过创建索引进行subset。每次都能节省setindex()的时间。&lt;/li&gt;
&lt;li&gt;通过检查属性，可以简单地重用已经存在的二级索引。&lt;/li&gt;
&lt;li&gt;语法简单。
注意参数on也可以用来指定主键。事实上，为了更佳的可读性，我们鼓励在参数on里面指定主键。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2-使用参数on和索引进行快速subset:3887792cd19298be3383c54afb194a11&#34;&gt;2.使用参数on和索引进行快速subset&lt;/h2&gt;

&lt;h4 id=&#34;a-参数i里的subset:3887792cd19298be3383c54afb194a11&#34;&gt;a) 参数i里的subset&lt;/h4&gt;

&lt;p&gt;－subset所有origin是“JFK”的行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flights[&amp;quot;JFK&amp;quot;, on = &amp;quot;origin&amp;quot;]
#        year month day dep_delay arr_delay carrier origin dest air_time distance hour
#     1: 2014     1   1        14        13      AA    JFK  LAX      359     2475    9
#     2: 2014     1   1        -3        13      AA    JFK  LAX      363     2475   11
#     3: 2014     1   1         2         9      AA    JFK  LAX      351     2475   19
#     4: 2014     1   1         2         1      AA    JFK  LAX      350     2475   13
#     5: 2014     1   1        -2       -18      AA    JFK  LAX      338     2475   21
#    ---
# 81479: 2014    10  31        -4       -21      UA    JFK  SFO      337     2586   17
# 81480: 2014    10  31        -2       -37      UA    JFK  SFO      344     2586   18
# 81481: 2014    10  31         0       -33      UA    JFK  LAX      320     2475   17
# 81482: 2014    10  31        -6       -38      UA    JFK  SFO      343     2586    9
# 81483: 2014    10  31        -6       -38      UA    JFK  LAX      323     2475   11

## alternatively
# flights[.(&amp;quot;JFK&amp;quot;), on = &amp;quot;origin&amp;quot;] (or) 
# flights[list(&amp;quot;JFK&amp;quot;), on = &amp;quot;origin&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;这段语句执行的subset也是通过创建二级索引，基于快速二分法搜索的。但记住，它不会把这个二级索引自动创建为data.table的一个属性。当然后面我们也会教你如何将它设置为一个属性。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;如果我们已经添加了一个二级索引了，那么参数on就可以直接使用这个二级索引，而不是再对整个航班信息flights进行计算。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们来看下面 verbose = TRUE 的用法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;setindex(flights, origin)
flights[&amp;quot;JFK&amp;quot;, on = &amp;quot;origin&amp;quot;, verbose = TRUE][1:5]
# names(on) = NULL. Assigning &#39;on&#39; to names(on)&#39; as well.
# Looking for existing (secondary) index... found. Reusing index.
# Starting bmerge ...done in 0 secs
#    year month day dep_delay arr_delay carrier origin dest air_time distance hour
# 1: 2014     1   1        14        13      AA    JFK  LAX      359     2475    9
# 2: 2014     1   1        -3        13      AA    JFK  LAX      363     2475   11
# 3: 2014     1   1         2         9      AA    JFK  LAX      351     2475   19
# 4: 2014     1   1         2         1      AA    JFK  LAX      350     2475   13
# 5: 2014     1   1        -2       -18      AA    JFK  LAX      338     2475   21
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;－如何对origin列和dest列进行subset
举个例子，如果我们想选取所有从“JFK”起飞到达“LAX”的所有航班：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flights[.(&amp;quot;JFK&amp;quot;, &amp;quot;LAX&amp;quot;), on = c(&amp;quot;origin&amp;quot;, &amp;quot;dest&amp;quot;)][1:5]
#    year month day dep_delay arr_delay carrier origin dest air_time distance hour
# 1: 2014     1   1        14        13      AA    JFK  LAX      359     2475    9
# 2: 2014     1   1        -3        13      AA    JFK  LAX      363     2475   11
# 3: 2014     1   1         2         9      AA    JFK  LAX      351     2475   19
# 4: 2014     1   1         2         1      AA    JFK  LAX      350     2475   13
# 5: 2014     1   1        -2       -18      AA    JFK  LAX      338     2475   21
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在参数i里面指定取值，在参数on里面指定列名。参数on必须是一个字符型的向量。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;因为计算索引非常快，所以我们不需要使用setindex()。除非你需要对某一列重复地进行subset操作。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;b-参数j里的select:3887792cd19298be3383c54afb194a11&#34;&gt;b) 参数j里的select&lt;/h4&gt;

&lt;p&gt;下面我们将要讨论的所有操作，跟我们在上一讲里面学习的类似。只是我们现在使用参数on。&lt;br /&gt;
－返回满足条件 origin = &amp;ldquo;LGA&amp;rdquo; and dest = &amp;ldquo;TPA&amp;rdquo;的 arr_delay列的值&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flights[.(&amp;quot;LGA&amp;quot;, &amp;quot;TPA&amp;quot;), .(arr_delay), on = c(&amp;quot;origin&amp;quot;, &amp;quot;dest&amp;quot;)]
#       arr_delay
#    1:         1
#    2:        14
#    3:       -17
#    4:        -4
#    5:       -12
#   ---          
# 1848:        39
# 1849:       -24
# 1850:       -12
# 1851:        21
# 1852:       -11
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;c-chaining:3887792cd19298be3383c54afb194a11&#34;&gt;c) Chaining&lt;/h4&gt;

&lt;p&gt;－在上面的基础上，使用chaining来将结果降序排列&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flights[.(&amp;quot;LGA&amp;quot;, &amp;quot;TPA&amp;quot;), .(arr_delay), on = c(&amp;quot;origin&amp;quot;, &amp;quot;dest&amp;quot;)][order(-arr_delay)]
#       arr_delay
#    1:       486
#    2:       380
#    3:       351
#    4:       318
#    5:       300
#   ---          
# 1848:       -40
# 1849:       -43
# 1850:       -46
# 1851:       -48
# 1852:       -49
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;d-参数j里的计算:3887792cd19298be3383c54afb194a11&#34;&gt;d) 参数j里的计算&lt;/h4&gt;

&lt;p&gt;－找出满足条件 origin = &amp;ldquo;LGA&amp;rdquo; and dest = &amp;ldquo;TPA&amp;rdquo;的 arr_delay列的最大值（航班到达的最长延误时间）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flights[.(&amp;quot;LGA&amp;quot;, &amp;quot;TPA&amp;quot;), max(arr_delay), on = c(&amp;quot;origin&amp;quot;, &amp;quot;dest&amp;quot;)]
# [1] 486
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;e-参数j里使用操作符-进行sub-assign:3887792cd19298be3383c54afb194a11&#34;&gt;e) 参数j里使用操作符&amp;rdquo;:=&amp;ldquo;进行sub-assign&lt;/h4&gt;

&lt;p&gt;在上一讲中，我们学习过了类似的功能。同样地，现在我们看看如何找到在flights里面，hours列所有可能的取值：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# get all &#39;hours&#39; in flights
flights[, sort(unique(hour))]
#  [1]  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，一共有25种不同的取值。但是0点和24点其实是同样的。下面我们把24全部替换成0，但是这次我们使用参数on。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flights[.(24L), hour := 0L, on = &amp;quot;hour&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在我们再来看看24是不是都被替换成0了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flights[, sort(unique(hour))]
#  [1]  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;这真是二级索引的一大优点。以前，只是为了更新一些行的hour列的取值，我们不得不调用函数setkey()将hour列设置为主键，这必须对整个data.table进行重新排序。但是现在，用参数on，原数据的顺序并没有改变，操作反而更快了！而代码还是如此简洁。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;f-通过参数by聚合:3887792cd19298be3383c54afb194a11&#34;&gt;f) 通过参数by聚合&lt;/h4&gt;

&lt;p&gt;－找到每月从“JFK”起飞的航班起飞的最长延误时间，并按照月份排序&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ans &amp;lt;- flights[&amp;quot;JFK&amp;quot;, max(dep_delay), keyby = month, on = &amp;quot;origin&amp;quot;]
head(ans)
#    month   V1
# 1:     1  881
# 2:     2 1014
# 3:     3  920
# 4:     4 1241
# 5:     5  853
# 6:     6  798
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果我们不使用二级索引，也就是不在参数on里面指定，那么我们就必须把origin设置为主键。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;g-参数mult:3887792cd19298be3383c54afb194a11&#34;&gt;g) 参数mult&lt;/h4&gt;

&lt;p&gt;参数mult和上一讲一样。它的默认值是“all”。我们可以选择是第一条还是最后一条符合条件的行被返回。&lt;br /&gt;
－subset满足条件dest ＝ “BOS” 和 “DAY”的第一行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flights[c(&amp;quot;BOS&amp;quot;, &amp;quot;DAY&amp;quot;), on = &amp;quot;dest&amp;quot;, mult = &amp;quot;first&amp;quot;]
#    year month day dep_delay arr_delay carrier origin dest air_time distance hour
# 1: 2014     1   1         3         1      AA    JFK  BOS       39      187   12
# 2: 2014     1   1        25        35      EV    EWR  DAY      102      533   17
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;－subset满足条件 origin ＝ “LGA” 或者 “JFK” 或者 “EWR”，并且 dest ＝ “XNA” 的最后一行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flights[.(c(&amp;quot;LGA&amp;quot;, &amp;quot;JFK&amp;quot;, &amp;quot;EWR&amp;quot;), &amp;quot;XNA&amp;quot;), on = c(&amp;quot;origin&amp;quot;, &amp;quot;dest&amp;quot;), mult = &amp;quot;last&amp;quot;]
#    year month day dep_delay arr_delay carrier origin dest air_time distance hour
# 1: 2014    10  31        -5       -11      MQ    LGA  XNA      165     1147    6
# 2:   NA    NA  NA        NA        NA      NA    JFK  XNA       NA       NA   NA
# 3: 2014    10  31        -2       -25      EV    EWR  XNA      160     1131    6
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;h-参数nomatch:3887792cd19298be3383c54afb194a11&#34;&gt;h) 参数nomatch&lt;/h4&gt;

&lt;p&gt;如果查询语句没有找到任何匹配的数据，通过指定参数nomatch，我们可以选择是返回 NA，还是忽略。&lt;br /&gt;
－在上面这个列子中，忽略没有实际意义的数据&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flights[.(c(&amp;quot;LGA&amp;quot;, &amp;quot;JFK&amp;quot;, &amp;quot;EWR&amp;quot;), &amp;quot;XNA&amp;quot;), mult = &amp;quot;last&amp;quot;, on = c(&amp;quot;origin&amp;quot;, &amp;quot;dest&amp;quot;), nomatch = 0L]
#    year month day dep_delay arr_delay carrier origin dest air_time distance hour
# 1: 2014    10  31        -5       -11      MQ    LGA  XNA      165     1147    6
# 2: 2014    10  31        -2       -25      EV    EWR  XNA      160     1131    6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;没有航班从“JFK”起飞到达“XNA”，所以结果里面，这一行被忽略了。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;3-自动索引:3887792cd19298be3383c54afb194a11&#34;&gt;3.自动索引&lt;/h2&gt;

&lt;p&gt;回顾一下，我们先学习如何通过主键使用快速二分法搜索进行subset。接着，我们学习了使用二级索引，它带来更好的效果，而且语法也更简洁。&lt;br /&gt;
等等，有没有更好的方法？有！优化R的原生语法，使用内置的索引。这样我们毋需使用新的语法，就能得到同样的效果。&lt;br /&gt;
这就是自动索引。&lt;br /&gt;
目前，它只支持操作符 == 和 %in% 。而且只对一列起作用。某一列会被自动创建为索引，并且作为data.table的属性保存起来。这跟参数on不同，参数on会每次创建一个临时索引，所以才会被叫做“二级索引”。&lt;/p&gt;

&lt;p&gt;让我们创建一个极大的data.table来凸显它的优势。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;set.seed(1L)
dt = data.table(x = sample(1e5L, 1e7L, TRUE), y = runif(100L))
print(object.size(dt), units = &amp;quot;Mb&amp;quot;)
# 114.4 Mb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当我们第一次对某一列使用 == 或者 %in% 的时候，会自动创建一个二级索引，它会被用来进行subset。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# have a look at all the attribute names
names(attributes(dt))
# [1] &amp;quot;names&amp;quot;             &amp;quot;row.names&amp;quot;         &amp;quot;class&amp;quot;             &amp;quot;.internal.selfref&amp;quot;

## run thefirst time
(t1 &amp;lt;- system.time(ans &amp;lt;- dt[x == 989L]))
#    user  system elapsed 
#   0.235   0.013   0.249
head(ans)
#      x         y
# 1: 989 0.5372007
# 2: 989 0.5642786
# 3: 989 0.7151100
# 4: 989 0.3920405
# 5: 989 0.9547465
# 6: 989 0.2914710

## secondary index is created
names(attributes(dt))
# [1] &amp;quot;names&amp;quot;             &amp;quot;row.names&amp;quot;         &amp;quot;class&amp;quot;             &amp;quot;.internal.selfref&amp;quot;
# [5] &amp;quot;index&amp;quot;

indices(dt)
# [1] &amp;quot;x&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一次subset的时候，就是创建索引的时候。因为创建二级索引只会引入一个排序向量，在很多情况下，这种操作符的方式会比扫描向量快得多。所以，从第二次subset开始，自动索引的优势就非常明显了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;## successive subsets
(t2 &amp;lt;- system.time(dt[x == 989L]))
#    user  system elapsed 
#   0.001   0.000   0.001
system.time(dt[x %in% 1989:2012])
#    user  system elapsed 
#   0.001   0.000   0.001
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;第一次subset花了0.228秒，但是第二次只花了0.001秒！&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;可以通过设置全局参数关闭自动索引：options(datatable.auto.index = FALSE)。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们正在将二分法搜索扩展到其它的操作符，比如 &amp;lt;, &amp;lt;= 和 &amp;gt;=。完成之后，就能直接用在其他操作符上了。&lt;br /&gt;
在将来，我们计划将自动索引扩展到参数中的其它列。&lt;/p&gt;

&lt;p&gt;在下一讲“结合和滚动结合”中，我们会学习使用主键和二级索引进行快速subset。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>data.table 教程3－主键、基于二分法搜索的subset</title>
      <link>http://youngspring1.github.io/post/2016/2016-03-22-datatable3/</link>
      <pubDate>Tue, 22 Mar 2016 23:58:42 +0800</pubDate>
      
      <guid>http://youngspring1.github.io/post/2016/2016-03-22-datatable3/</guid>
      <description>

&lt;p&gt;目录：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://youngspring1.github.io/post/2016/2016-03-13-datatable1/&#34;&gt;data.table 介绍&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://youngspring1.github.io/post/2016/2016-03-21-datatable2/&#34;&gt;语义引用&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://youngspring1.github.io/post/2016/2016-03-22-datatable3/&#34;&gt;主键、基于二分法搜索的subset&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://youngspring1.github.io/post/2016/2016-04-02-datatable4/&#34;&gt;二次索引和自动索引&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://youngspring1.github.io/post/2016/2016-04-08-datatable5/&#34;&gt;数据拆分和合并&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;原文地址：&lt;br /&gt;
&lt;a href=&#34;https://github.com/Rdatatable/data.table/wiki/Getting-started&#34;&gt;data.table/wiki/Getting-started&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;本教程主要提供给那些已经熟悉data.table的语法、懂得subset行select列、知道如何添加／更新／删除列的人员学习。如果你对这些不熟悉，请学习上面两讲 &lt;a href=&#34;http://youngspring1.github.io/post/2016-03-13-datatable1/&#34;&gt;data.table 介绍&lt;/a&gt; 和 &lt;a href=&#34;http://youngspring1.github.io/post/2016-03-21-datatable2/&#34;&gt;语义引用&lt;/a&gt;。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;数据:e288dbec01fe10fa9bd0f8ade4810458&#34;&gt;数据&lt;/h2&gt;

&lt;p&gt;我们继续使用上一讲中使用的航班信息flights。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flights &amp;lt;- fread(&amp;quot;https://raw.githubusercontent.com/wiki/arunsrinivasan/    flights/NYCflights14/flights14.csv&amp;quot;)
flights
#         year month day dep_time dep_delay arr_time arr_delay cancelled carrier tailnum flight
#      1: 2014     1   1      914        14     1238        13         0      AA  N338AA      1
#      2: 2014     1   1     1157        -3     1523        13         0      AA  N335AA      3
#      3: 2014     1   1     1902         2     2224         9         0      AA  N327AA     21
#      4: 2014     1   1      722        -8     1014       -26         0      AA  N3EHAA     29
#      5: 2014     1   1     1347         2     1706         1         0      AA  N319AA    117
#     ---                                                                                      
# 253312: 2014    10  31     1459         1     1747       -30         0      UA  N23708   1744
# 253313: 2014    10  31      854        -5     1147       -14         0      UA  N33132   1758
# 253314: 2014    10  31     1102        -8     1311        16         0      MQ  N827MQ   3591
# 253315: 2014    10  31     1106        -4     1325        15         0      MQ  N511MQ   3592
# 253316: 2014    10  31      824        -5     1045         1         0      MQ  N813MQ   3599
#         origin dest air_time distance hour min
#      1:    JFK  LAX      359     2475    9  14
#      2:    JFK  LAX      363     2475   11  57
#      3:    JFK  LAX      351     2475   19   2
#      4:    LGA  PBI      157     1035    7  22
#      5:    JFK  LAX      350     2475   13  47
#     ---                                       
# 253312:    LGA  IAH      201     1416   14  59
# 253313:    EWR  IAH      189     1400    8  54
# 253314:    LGA  RDU       83      431   11   2
# 253315:    LGA  DTW       75      502   11   6
# 253316:    LGA  SDF      110      659    8  24
dim(flights)
# [1] 253316     17
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;介绍:e288dbec01fe10fa9bd0f8ade4810458&#34;&gt;介绍&lt;/h2&gt;

&lt;p&gt;在这一讲，我们会：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* 介绍“主键”的概念，在参数i里面，设置并使用主键进行基于快速二分法搜索的subset。
* 学习如何将基于主键的subset，与参数i和by相结合，就像以前做的一样。
* 学习另外两个有用的参数 mult 和 nomatch
* 最后总结一下主键的优越性：基于快速二分法搜索的subset的表现，并和传统的vector scan approach对比。
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;1-主键:e288dbec01fe10fa9bd0f8ade4810458&#34;&gt;1.主键&lt;/h2&gt;

&lt;h4 id=&#34;a-什么是主键:e288dbec01fe10fa9bd0f8ade4810458&#34;&gt;a) 什么是主键&lt;/h4&gt;

&lt;p&gt;在&lt;a href=&#34;http://youngspring1.github.io/post/2016-03-13-datatable1/&#34;&gt;data.table 介绍&lt;/a&gt;里，我们学习了如何在参数i里指定逻辑表达式和行号subset行，以及如何使用 order().在这一讲，我们会学习如何使用主键subset行，而且这难以置信的快。&lt;br /&gt;
但首先，我们从data.frame开始。所有的data.frame都有一个行名的属性。看下面这个data.frame DF。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;set.seed(1L)
DF = data.frame(ID1 = sample(letters[1:2], 10, TRUE), 
                ID2 = sample(1:3, 10, TRUE),
                val = sample(10), 
                stringsAsFactors = FALSE,
                row.names = sample(LETTERS[1:10]))
DF
#   ID1 ID2 val
# C   a   3   5
# D   a   1   6
# E   b   2   4
# G   a   1   2
# B   b   1  10
# H   a   2   8
# I   b   1   9
# F   b   2   1
# J   a   3   7
# A   b   2   3

rownames(DF)
#  [1] &amp;quot;C&amp;quot; &amp;quot;D&amp;quot; &amp;quot;E&amp;quot; &amp;quot;G&amp;quot; &amp;quot;B&amp;quot; &amp;quot;H&amp;quot; &amp;quot;I&amp;quot; &amp;quot;F&amp;quot; &amp;quot;J&amp;quot; &amp;quot;A&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以用行名来subset一行，就像这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DF[&amp;quot;C&amp;quot;, ]
#   ID1 ID2 val
# C   a   3   5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;行名，或多或少，算是一个data.frame的索引。然而，&lt;br /&gt;
1. 每行都有且只有一个行名。
但是，一个人可能有两个名字，比如名字和中间名。当编纂电话簿的时候，这就非常有用。
2. 而且行名必须是独一无二的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rownames(DF) = sample(LETTERS[1:5], 10, TRUE)
# Warning: non-unique values when setting &#39;row.names&#39;: &#39;C&#39;, &#39;D&#39;
# Error in `row.names&amp;lt;-.data.frame`(`*tmp*`, value = value): duplicate &#39;row.names&#39; are not allowed
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面我们来看看data.table吧。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DT = as.data.table(DF)
DT
#     ID1 ID2 val
#  1:   a   3   5
#  2:   a   1   6
#  3:   b   2   4
#  4:   a   1   2
#  5:   b   1  10
#  6:   a   2   8
#  7:   b   1   9
#  8:   b   2   1
#  9:   a   3   7
# 10:   b   2   3

rownames(DT)
#  [1] &amp;quot;1&amp;quot;  &amp;quot;2&amp;quot;  &amp;quot;3&amp;quot;  &amp;quot;4&amp;quot;  &amp;quot;5&amp;quot;  &amp;quot;6&amp;quot;  &amp;quot;7&amp;quot;  &amp;quot;8&amp;quot;  &amp;quot;9&amp;quot;  &amp;quot;10&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* 行名被重置了。
* data.table从来不使用行名。既然data.table集成了data.frame，那它还是有行名这个属性的，但是从来不使用。马上我们就知道为什么了。
如果想保持行名，在调用 as.data.table()的时候指定 keep.rownames = TRUE，这回创建一个叫做 rn的列，并且将列名赋值给这一列。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而在data.table里，我们使用主键。主键是更有效的行名。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;主键及其特性
* 我们可以对多个列设置主键，这些列可能是不同的类型－integer, numeric, character, factor, integer64等等。但还不支持list和complex。
* 不强制唯一性，也就是说，不同列的主键可以是一样的。既然行可以通过主键排序，那么排序的时候，具有同样主键的一些行，会被排在一起。
* 设置主键这个过程分两步：
  a.根据指定的列，对data.table重新排序，而且总是按升序排列。
  b.对于data.table，通过设置一个叫做 sorted 的属性，来把那些列标记为主键列。
  既然是排序，一个data.table最多只能有一个主键，因为它不能按照两种方法排序。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在教程接下来的部分，我们一直都是用航班信息 flights 来讲解。&lt;/p&gt;

&lt;h3 id=&#34;b-设置-获取-使用主键:e288dbec01fe10fa9bd0f8ade4810458&#34;&gt;b) 设置／获取／使用主键&lt;/h3&gt;

&lt;p&gt;－如何将 origin列设置为主键&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;setkey(flights, origin)
head(flights)
#    year month day dep_time dep_delay arr_time arr_delay cancelled carrier tailnum flight origin
# 1: 2014     1   1     1824         4     2145         0         0      AA  N3DEAA    119    EWR
# 2: 2014     1   1     1655        -5     2003       -17         0      AA  N5CFAA    172    EWR
# 3: 2014     1   1     1611       191     1910       185         0      AA  N471AA    300    EWR
# 4: 2014     1   1     1449        -1     1753        -2         0      AA  N4WNAA    320    EWR
# 5: 2014     1   1      607        -3      905       -10         0      AA  N5DMAA   1205    EWR
# 6: 2014     1   1      949         4     1243       -17         0      AA  N491AA   1223    EWR
#    dest air_time distance hour min
# 1:  LAX      339     2454   18  24
# 2:  MIA      161     1085   16  55
# 3:  DFW      214     1372   16  11
# 4:  DFW      214     1372   14  49
# 5:  MIA      154     1085    6   7
# 6:  DFW      215     1372    9  49

## alternatively we can provide character vectors to the function &#39;setkeyv()&#39;
# setkeyv(flights, &amp;quot;origin&amp;quot;) # useful to program with
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* 你可以给函数setkey() 传入列名作为参数，不需要引号。这在交互式使用的时候特别方便。
* 换一种方式，你可以给函数setkeyv() 传一个字符型的向量，这个向量里保存的是列名。这在把列作为参数传给一个新创建的函数，来设置主键的时候特别方便。
* 注意，我们不需要将结果赋值给一个变量。这是因为，setkey() 和 setkeyv()可以直接更新输入的data.table，就和上一讲中的操作符&amp;quot;:=&amp;quot;一样。它们没有返回值。
* 现在这个data.table已经按照我们提供的 origin列重新排序了。虽然是重新排序，但我们只需要请求和data.table的行数等长的一列这么大的内存空间。你看，又节省内存开销了。
* 你也可以在创建data.table的时候，调用函数data.table() 的参数 key=，直接设置主键，参数key的值是列名的字符型向量。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;set* and :=:
在data.table里，操作符&amp;quot;:=&amp;quot;和所有的以set开头函数（比如setkey,setorder,setname等）一样，它们都会更新输入的原数据。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一旦将某一列设置成data.table的主键，就可以在参数i里指定 .()来subset那些主键了。回忆一下，.()就是 list()的别名。&lt;/p&gt;

&lt;p&gt;－使用主键origin 来subset所有origin是&amp;rdquo;JFK&amp;rdquo;的行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flights[.(&amp;quot;JFK&amp;quot;)]
#        year month day dep_time dep_delay arr_time arr_delay cancelled carrier tailnum flight origin
#     1: 2014     1   1      914        14     1238        13         0      AA  N338AA      1    JFK
#     2: 2014     1   1     1157        -3     1523        13         0      AA  N335AA      3    JFK
#     3: 2014     1   1     1902         2     2224         9         0      AA  N327AA     21    JFK
#     4: 2014     1   1     1347         2     1706         1         0      AA  N319AA    117    JFK
#     5: 2014     1   1     2133        -2       37       -18         0      AA  N323AA    185    JFK
#    ---                                                                                             
# 81479: 2014    10  31     1705        -4     2024       -21         0      UA  N596UA    512    JFK
# 81480: 2014    10  31     1827        -2     2133       -37         0      UA  N568UA    514    JFK
# 81481: 2014    10  31     1753         0     2039       -33         0      UA  N518UA    535    JFK
# 81482: 2014    10  31      924        -6     1228       -38         0      UA  N512UA    541    JFK
# 81483: 2014    10  31     1124        -6     1408       -38         0      UA  N590UA    703    JFK
#        dest air_time distance hour min
#     1:  LAX      359     2475    9  14
#     2:  LAX      363     2475   11  57
#     3:  LAX      351     2475   19   2
#     4:  LAX      350     2475   13  47
#     5:  LAX      338     2475   21  33
#    ---                                
# 81479:  SFO      337     2586   17   5
# 81480:  SFO      344     2586   18  27
# 81481:  LAX      320     2475   17  53
# 81482:  SFO      343     2586    9  24
# 81483:  LAX      323     2475   11  24

## alternatively
# flights[J(&amp;quot;JFK&amp;quot;)] (or) flights[list(&amp;quot;JFK&amp;quot;)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* 因为已经将主键设置为 origin列了，所以只要直接指定&amp;quot;JFK&amp;quot;就可以了。这里 .()用来在data.table的主键（也就是flights 的 origin列）里，查找&amp;quot;JFK&amp;quot;。
* 首先，满足&amp;quot;JFK&amp;quot;条件的行的索引都被获取到。然后，这些行的哪些信息是必要的呢。既然参数j里没有指定任何表达式，这些行的所有列都被返回了。
* 如果主键是字符型的列，那么可以省略 .()，就像用行名subset一个data.frame的行的时候。
flights[&amp;quot;JFK&amp;quot;]              ## same as flights[.(&amp;quot;JFK&amp;quot;)]

* 我们可以根据需要指定多个值
flights[c(&amp;quot;JFK&amp;quot;, &amp;quot;LGA&amp;quot;)]    ## same as flights[.(c(&amp;quot;JFK&amp;quot;, &amp;quot;LGA&amp;quot;))]
这返回所有 origin列是“JFK” 或者 “LGA”的所有行。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;－如何获得被设置为data.table的主键的那一列的列名
使用函数 key()。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;key(flights)
# [1] &amp;quot;origin&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* 函数 key() 返回主键列名的字符型向量。
* 如果data.table没有设置过主键，返回 NULL。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;c-主键和多个列:e288dbec01fe10fa9bd0f8ade4810458&#34;&gt;c) 主键和多个列&lt;/h4&gt;

&lt;p&gt;主键是更有效的行名。我们可以将多个列设置为主键，它们可以是不同的类型。
－如何将 origin列 和 dest列 都设置为主键&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;setkey(flights, origin, dest)
head(flights)
#    year month day dep_time dep_delay arr_time arr_delay cancelled carrier tailnum flight origin
# 1: 2014     1   2      724        -2      810       -25         0      EV  N11547   4373    EWR
# 2: 2014     1   3     2313        88        9        79         0      EV  N18120   4470    EWR
# 3: 2014     1   4     1526       220     1618       211         0      EV  N11184   4373    EWR
# 4: 2014     1   4      755        35      848        19         0      EV  N14905   4551    EWR
# 5: 2014     1   5      817        47      921        42         0      EV  N19966   4470    EWR
# 6: 2014     1   5     2301        66        2        62         0      EV  N19966   4682    EWR
#    dest air_time distance hour min
# 1:  ALB       30      143    7  24
# 2:  ALB       29      143   23  13
# 3:  ALB       32      143   15  26
# 4:  ALB       32      143    7  55
# 5:  ALB       26      143    8  17
# 6:  ALB       31      143   23   1

## or alternatively
# setkeyv(flights, c(&amp;quot;origin&amp;quot;, &amp;quot;dest&amp;quot;)) # provide a character vector of column names

key(flights)
# [1] &amp;quot;origin&amp;quot; &amp;quot;dest&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* data.table先按 origin列 排序，再按 dest列 排序。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;－subset所有满足条件 origin是&amp;rdquo;JFK&amp;rdquo;、dest是&amp;rdquo;MIA&amp;rdquo;的行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flights[.(&amp;quot;JFK&amp;quot;, &amp;quot;MIA&amp;quot;)]
#       year month day dep_time dep_delay arr_time arr_delay cancelled carrier tailnum flight origin
#    1: 2014     1   1     1509        -1     1828       -17         0      AA  N5FJAA    145    JFK
#    2: 2014     1   1      917         7     1227        -8         0      AA  N5DWAA   1085    JFK
#    3: 2014     1   1     1227         2     1534        -1         0      AA  N635AA   1697    JFK
#    4: 2014     1   1      546         6      853         3         0      AA  N5CGAA   2243    JFK
#    5: 2014     1   1     1736         6     2043       -12         0      AA  N397AA   2351    JFK
#   ---                                                                                             
# 2746: 2014    10  31     1659        -1     1956       -22         0      AA  N5FNAA   2351    JFK
# 2747: 2014    10  31      826        -3     1116       -20         0      AA  N5EYAA   1085    JFK
# 2748: 2014    10  31      647         2      941       -17         0      AA  N5BTAA   1101    JFK
# 2749: 2014    10  31      542        -3      834       -12         0      AA  N3ETAA   2299    JFK
# 2750: 2014    10  31     1944        29     2232         4         0      AA  N5FSAA   2387    JFK
#       dest air_time distance hour min
#    1:  MIA      161     1089   15   9
#    2:  MIA      166     1089    9  17
#    3:  MIA      164     1089   12  27
#    4:  MIA      157     1089    5  46
#    5:  MIA      154     1089   17  36
#   ---                                
# 2746:  MIA      148     1089   16  59
# 2747:  MIA      146     1089    8  26
# 2748:  MIA      150     1089    6  47
# 2749:  MIA      150     1089    5  42
# 2750:  MIA      146     1089   19  44
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;这里发生了什么事？
* 理解内部的处理步骤很重要。首先，用&amp;quot;JFK&amp;quot;和第一个主键 origin列匹配；然后，在匹配上的这些行里，用“MIA”和第二个主键 dest列匹配，这样来获取所有符合这两个条件的行的索引。
* 既然我们没有指定参数j，那就会返回所有符合上面索引的行。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;－subset所有仅仅满足条件dest是&amp;rdquo;MIA&amp;rdquo;的行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flights[.(unique(origin), &amp;quot;MIA&amp;quot;)]
#       year month day dep_time dep_delay arr_time arr_delay cancelled carrier tailnum flight origin
#    1: 2014     1   1     1655        -5     2003       -17         0      AA  N5CFAA    172    EWR
#    2: 2014     1   1      607        -3      905       -10         0      AA  N5DMAA   1205    EWR
#    3: 2014     1   1     1125        -5     1427        -8         0      AA  N3AGAA   1623    EWR
#    4: 2014     1   1     1533        43     1840        42         0      UA  N491UA    244    EWR
#    5: 2014     1   1     2130        60       29        49         0      UA  N476UA    308    EWR
#   ---                                                                                             
# 9924: 2014    10  31     1348       -11     1658        -8         0      AA  N3AMAA   2283    LGA
# 9925: 2014    10  31      950        -5     1257       -11         0      AA  N3LFAA   2287    LGA
# 9926: 2014    10  31      658        -2     1017        10         0      AA  N3HNAA   2451    LGA
# 9927: 2014    10  31     1913        -2     2212       -16         0      AA  N3LFAA   2455    LGA
# 9928: 2014    10  31     1530         1     1839       -11         0      US  N768US   1715    LGA
#       dest air_time distance hour min
#    1:  MIA      161     1085   16  55
#    2:  MIA      154     1085    6   7
#    3:  MIA      157     1085   11  25
#    4:  MIA      155     1085   15  33
#    5:  MIA      162     1085   21  30
#   ---                                
# 9924:  MIA      157     1096   13  48
# 9925:  MIA      150     1096    9  50
# 9926:  MIA      156     1096    6  58
# 9927:  MIA      156     1096   19  13
# 9928:  MIA      164     1096   15  30
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;这里发生了什么事？
* 回忆一下刚刚讲的处理步骤。首先，找到满足第一个主键origin列的条件的行；然后在这个结果中，找到满足第二个主键dest列是“MIA”的行。我们不能简单地事先跳过第一个主键列。因此，我们必须通过主键 origin列，获得它所有可能的取值。
* “MIA”会被自动补足成跟 unique(origin) 同样的长度，也就是3。
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-和参数j-参数by一起使用:e288dbec01fe10fa9bd0f8ade4810458&#34;&gt;2. 和参数j、参数by一起使用&lt;/h2&gt;

&lt;p&gt;到目前为止，我们学习的都是同样的概念，也就是通过参数i取得行，只是使用了主键这种新的方法。那么同样的，我们在参数j和参数by里面使用主键，也没什么大惊小怪的。我们通过几个例子来说明。&lt;/p&gt;

&lt;h4 id=&#34;a-在参数j里面select:e288dbec01fe10fa9bd0f8ade4810458&#34;&gt;a) 在参数j里面select&lt;/h4&gt;

&lt;p&gt;－返回符合 origin = &amp;ldquo;LGA&amp;rdquo; 和 dest = &amp;ldquo;TPA&amp;rdquo;这两个条件的 arr_delay列&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;key(flights)
# [1] &amp;quot;origin&amp;quot; &amp;quot;dest&amp;quot;
flights[.(&amp;quot;LGA&amp;quot;, &amp;quot;TPA&amp;quot;), .(arr_delay)]
#       arr_delay
#    1:         1
#    2:        14
#    3:       -17
#    4:        -4
#    5:       -12
#   ---          
# 1848:        39
# 1849:       -24
# 1850:       -12
# 1851:        21
# 1852:       -11
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* 通过基于主键的subset，我们获得了满足 origin == &amp;quot;LGA&amp;quot; 和 dest == “TPA”这两个条件的行索引。
* 现在我们已经获得了这些行的索引，而参数j只请求了 arr_delay列。那么我们简单地从这些行索引中选取 arr_delay列，就像我们在第一讲中做的那样。
* 同以前一样，我们也可以指定 with = FALSE：
flights[.(&amp;quot;LGA&amp;quot;, &amp;quot;TPA&amp;quot;), &amp;quot;arr_delay&amp;quot;, with=FALSE]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;b-chaining表达式:e288dbec01fe10fa9bd0f8ade4810458&#34;&gt;b) Chaining表达式&lt;/h4&gt;

&lt;p&gt;－在上面的基础上，将结果用chaining表达式按降序排列&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flights[.(&amp;quot;LGA&amp;quot;, &amp;quot;TPA&amp;quot;), .(arr_delay)][order(-arr_delay)]
#       arr_delay
#    1:       486
#    2:       380
#    3:       351
#    4:       318
#    5:       300
#   ---          
# 1848:       -40
# 1849:       -43
# 1850:       -46
# 1851:       -48
# 1852:       -49
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;c-在参数j里运算:e288dbec01fe10fa9bd0f8ade4810458&#34;&gt;c) 在参数j里运算&lt;/h4&gt;

&lt;p&gt;－找出符合 origin = &amp;ldquo;LGA&amp;rdquo; 和 dest = &amp;ldquo;TPA&amp;rdquo;这两个条件的航班的最大到达延误时间&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flights[.(&amp;quot;LGA&amp;quot;, &amp;quot;TPA&amp;quot;), max(arr_delay)]
# [1] 486
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* 注意一下，这个结果(486)，就是b)的结果的第一行的值。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;d-在参数j里使用操作符-来sub-assign:e288dbec01fe10fa9bd0f8ade4810458&#34;&gt;d) 在参数j里使用操作符&amp;rdquo;:=&amp;ldquo;来sub-assign&lt;/h4&gt;

&lt;p&gt;我们已经在第二讲&lt;a href=&#34;http://youngspring1.github.io/post/2016-03-21-datatable2/&#34;&gt;语义引用&lt;/a&gt;里学习了几个例子了。现在来看看filghts里的 hours列。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# get all &#39;hours&#39; in flights
flights[, sort(unique(hour))]
#  [1]  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，hour列有25种不同的取值。但是0点和24点应该是一样的，我们来把24点全部替换成0点。这次我们用主键来做。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;setkey(flights, hour)
key(flights)
# [1] &amp;quot;hour&amp;quot;
flights[.(24), hour := 0L]
key(flights)
# NULL
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* 我们首先将 hour列设置为主键。这会将flights按照 hour列重新排序，并且将 hour列标记为主键。
* 现在我们用 .()标记对hour列来subset。我们subset所有值为24的行的索引。
* 对于这些行，我们将主键列的值替换为0.
* 既然我们替换了主键列的值，flights也不再按照 hour列排序了。因此，主键被自动去除了，它被设置为NULL。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在，flights的hour列里，应该没有24了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flights[, sort(unique(hour))]
#  [1]  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;e-用参数by聚合:e288dbec01fe10fa9bd0f8ade4810458&#34;&gt;e) 用参数by聚合&lt;/h4&gt;

&lt;p&gt;我们先将 origin列 和 dest列设置为主键。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;setkey(flights, origin, dest)
key(flights)
# [1] &amp;quot;origin&amp;quot; &amp;quot;dest&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;－获取每个月从“JFK”起飞的航班的最大起飞延误时间，按月排序&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ans &amp;lt;- flights[&amp;quot;JFK&amp;quot;, max(dep_delay), keyby=month]
head(ans)
#    month   V1
# 1:     1  881
# 2:     2 1014
# 3:     3  920
# 4:     4 1241
# 5:     5  853
# 6:     6  798
key(ans)
# [1] &amp;quot;month&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* 我们对主键 origin列进行subset，得到了所有起飞机场是“JFK”的行索引。
* 现在我们已经得到这些行的索引了，我们只需要两列－用来分组的month列，和用来计算每组最大值的dep_delay列。data.table的查询都被优化过了，因此在参数i取得的行的基础上，再subset这两列，效率和内存开销都很可观。
* 在subset的时候，我们按month分组，再计算dep_delay列的最大值。
* 我们使用参数keyby来自动将month设置为结果的主键。现在我们理解了为什么叫keyby吧。它使得结果不仅按month列排序，而且将month设置为主键。
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3-另外两个参数mult和nomatch:e288dbec01fe10fa9bd0f8ade4810458&#34;&gt;3. 另外两个参数mult和nomatch&lt;/h2&gt;

&lt;h4 id=&#34;a-参数mult:e288dbec01fe10fa9bd0f8ade4810458&#34;&gt;a) 参数mult&lt;/h4&gt;

&lt;p&gt;对于每次查询，我们可以通过参数mult，指定所有符合条件的行“all”都被返回，还是只返回第一行“first”或者最后一行“last”。默认是所有的行“all”。&lt;br /&gt;
－获取符合origin = &amp;ldquo;JFK&amp;rdquo; 且 dest = &amp;ldquo;MIA&amp;rdquo;的数据的第一行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flights[.(&amp;quot;JFK&amp;quot;, &amp;quot;MIA&amp;quot;), mult=&amp;quot;first&amp;quot;]
#    year month day dep_time dep_delay arr_time arr_delay cancelled carrier tailnum flight origin
# 1: 2014     1   1      546         6      853         3         0      AA  N5CGAA   2243    JFK
#    dest air_time distance hour min
# 1:  MIA      157     1089    5  46
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;－获取符合origin = &amp;ldquo;LGA&amp;rdquo;或&amp;rdquo;JFK&amp;rdquo;或&amp;rdquo;EWR&amp;rdquo; 且 dest = &amp;ldquo;XNA&amp;rdquo;的数据的最后一行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flights[.(c(&amp;quot;LGA&amp;quot;, &amp;quot;JFK&amp;quot;, &amp;quot;EWR&amp;quot;), &amp;quot;XNA&amp;quot;), mult=&amp;quot;last&amp;quot;]
#    year month day dep_time dep_delay arr_time arr_delay cancelled carrier tailnum flight origin
# 1: 2014     5  23     1803       163     2003       148         0      MQ  N515MQ   3553    LGA
# 2:   NA    NA  NA       NA        NA       NA        NA        NA      NA      NA     NA    JFK
# 3: 2014     2   3     1208       231     1516       268         0      EV  N14148   4419    EWR
#    dest air_time distance hour min
# 1:  XNA      158     1147   18   3
# 2:  XNA       NA       NA   NA  NA
# 3:  XNA      184     1131   12   8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* JFK”, “XNA”不匹配flights的任何一条数据，因此返回 NA。
* 再强调一下，参数i里查询语句的第二个主键dest列，&amp;quot;XNA&amp;quot;会被自动补足成跟第一个主键的取值等长，也就是3。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;b-参数nomatch:e288dbec01fe10fa9bd0f8ade4810458&#34;&gt;b) 参数nomatch&lt;/h4&gt;

&lt;p&gt;我们可以通过参数nomatch，指定在没有找到符合条件的数据的情况下，是返回NA呢，还是跳过（不返回）。&lt;br /&gt;
－跟前一个例子一样，选取能找到的数据&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flights[.(c(&amp;quot;LGA&amp;quot;, &amp;quot;JFK&amp;quot;, &amp;quot;EWR&amp;quot;), &amp;quot;XNA&amp;quot;), mult=&amp;quot;last&amp;quot;, nomatch = 0L]
#    year month day dep_time dep_delay arr_time arr_delay cancelled carrier tailnum flight origin
# 1: 2014     5  23     1803       163     2003       148         0      MQ  N515MQ   3553    LGA
# 2: 2014     2   3     1208       231     1516       268         0      EV  N14148   4419    EWR
#    dest air_time distance hour min
# 1:  XNA      158     1147   18   3
# 2:  XNA      184     1131   12   8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* nomatch的默认是是NA。设置 nomatch = 0L 跳过哪些不存在的数据。
* JFK”, “XNA”不匹配flights的任何一条数据，因此就被跳过了。
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;4-二分法搜索-vs-向量扫描:e288dbec01fe10fa9bd0f8ade4810458&#34;&gt;4. 二分法搜索 vs 向量扫描&lt;/h2&gt;

&lt;p&gt;到目前为止，我们学习了如何设置和使用主键来subset。但是它的优点是什么呢？举个例子，除了这么做：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# key by origin,dest columns
flights[.(&amp;quot;JFK&amp;quot;, &amp;quot;MIA&amp;quot;)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们还可以这样做：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flights[origin == &amp;quot;JFK&amp;quot; &amp;amp; dest == &amp;quot;MIA&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一个显而易见的优点是，看上去更短。但是它的优点可不只是这个，事实上，基于二分法搜索的subset非常快速。&lt;/p&gt;

&lt;h4 id=&#34;a-二分法搜索:e288dbec01fe10fa9bd0f8ade4810458&#34;&gt;a) 二分法搜索&lt;/h4&gt;

&lt;p&gt;为了说明，我们创建一个有两千万行、三列的样本数据，将它的主键设置为x列和y列。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;set.seed(2L)
N = 2e7L
DT = data.table(x = sample(letters, N, TRUE), 
                y = sample(1000L, N, TRUE), 
                val=runif(N), key = c(&amp;quot;x&amp;quot;, &amp;quot;y&amp;quot;))
print(object.size(DT), units=&amp;quot;Mb&amp;quot;)
# 381.5 Mb

key(DT)
# [1] &amp;quot;x&amp;quot; &amp;quot;y&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;DT大约有 380 MB。这不算特别大，但是足够我们体现二分法搜索的优点了。&lt;br /&gt;
用第一讲&lt;a href=&#34;http://youngspring1.github.io/post/2016-03-13-datatable1/&#34;&gt;data.table 介绍&lt;/a&gt;我们学过的知识，我们可以subset 那些 x = &amp;ldquo;g&amp;rdquo; 和 y = 877 的行。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;## (1) Usual way of subsetting - vector scan approach
t1 &amp;lt;- system.time(ans1 &amp;lt;- DT[x == &amp;quot;g&amp;quot; &amp;amp; y == 877L])
t1
#    user  system elapsed 
#   0.871   0.022   0.919
head(ans1)
#    x   y       val
# 1: g 877 0.3946652
# 2: g 877 0.9424275
# 3: g 877 0.7068512
# 4: g 877 0.6959935
# 5: g 877 0.9673482
# 6: g 877 0.4842585
dim(ans1)
# [1] 761   3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在我们用主键来试着做一下。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;## (2) Subsetting using keys
t2 &amp;lt;- system.time(ans2 &amp;lt;- DT[.(&amp;quot;g&amp;quot;, 877L)])
t2
#    user  system elapsed 
#   0.001   0.000   0.002
head(ans2)
#    x   y       val
# 1: g 877 0.3946652
# 2: g 877 0.9424275
# 3: g 877 0.7068512
# 4: g 877 0.6959935
# 5: g 877 0.9673482
# 6: g 877 0.4842585
dim(ans2)
# [1] 761   3

identical(ans1$val, ans2$val)
# [1] TRUE
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(2)比(1)快了460倍！&lt;/p&gt;

&lt;h4 id=&#34;b-为什么用主键subset能这么快:e288dbec01fe10fa9bd0f8ade4810458&#34;&gt;b) 为什么用主键subset能这么快?&lt;/h4&gt;

&lt;p&gt;为了理解这些，我们先看第一种方法(1)向量扫描。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;向量扫描
* 在所有两千条数据中，逐行搜索 x列里值为“g”的行。这会生成一个有两千行的逻辑向量，根据和x列的批评结果，它每个元素的取值可能是TRUE, FALSE 以及 NA。
* 相似的，在所有两千条数据中，逐行搜索 y列里值为“877”的行，再保存在另一个逻辑向量里面。
* 操作符&amp;quot;&amp;amp;&amp;quot;对上面两个逻辑向量进行“且”运算，返回结果为TRUE的行
这就是所谓的“向量扫描”。效率非常低，特别是数据量很大、需要重复subset的时候。因为它每次不得不对整个数据全盘扫描。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在我们开看看第二种方法(2)二分法搜索。回忆一下前面“a)什么是主键”里的定义，根据主键列重新排序。既然数据被排序了，我们就不需要再对整个数据进行扫描。我们用二分法搜索的时间开销是 O(log n)，而向量扫描的时间开销是 O(n)，其中n是data.table的行数。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;二分法搜索
这里有一个简单的示例。看看下面这组排过序的数字：
1, 5, 10, 19, 22, 23, 30
假设我们希望找到数字1的位置，用二分法搜索（因为这组数字是排过序的），我们是这么做的：
* 从中间的数开始，它是19，不是1，而且 1&amp;lt;19。
* 既然我们要找的数字1小于19，那它应该排在19前面。所以我们可以无视19后面的那一半数据，因为它们都大于19.
* 现在我们的数据只剩下1, 5, 10。再找到中间的数5，它不是1，而且 1&amp;lt;5。
* 现在我们的数据只剩下1。符合条件。这就是我们要找的数。
相反的，向量扫描需要扫描所有的数字，在这个例子中是7。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;显而易见的，我们每次搜索的时候，搜索量都是原先的一半。这就是为什么基于二分法搜索的subset是如此的快。&lt;br /&gt;
因为data.table的行在内存中是连续存储的，这种subset的操作也很节省缓存，这有利于处理速度。&lt;br /&gt;
另外，既然我们不需要创建超大（跟原数据有同样多的行）的逻辑向量，就能取得匹配的行的索引，这种subset也能节省内存。&lt;/p&gt;

&lt;h2 id=&#34;总结:e288dbec01fe10fa9bd0f8ade4810458&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;在这一讲，我们学习了通过设置主键来subset行。设置主键使用了二分法搜索似的subset的操作变得惊人的快。特别的，我们学习了如何：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* 设置主键，并使用主键subset行。
* 更快的在参数i里通过主键subset行的索引。
* 将主键和参数j、参数by一起使用。注意参数j和参数by的使用方法和以前一样。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们大概不需要用主键来进行聚合的操作，除非数据了极其巨大，使得我们需要重复地做很多次subset，这就会让效果变得很醒目。&lt;br /&gt;
然而，当连结两个data.table的时候，设置主键是必要的。这是下一讲的主题。&lt;br /&gt;
我们会详细讲解根据主键列来连结两个data.table。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>data.table 教程2－语义引用</title>
      <link>http://youngspring1.github.io/post/2016/2016-03-21-datatable2/</link>
      <pubDate>Mon, 21 Mar 2016 19:56:45 +0800</pubDate>
      
      <guid>http://youngspring1.github.io/post/2016/2016-03-21-datatable2/</guid>
      <description>

&lt;p&gt;目录：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://youngspring1.github.io/post/2016/2016-03-13-datatable1/&#34;&gt;data.table 介绍&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://youngspring1.github.io/post/2016/2016-03-21-datatable2/&#34;&gt;语义引用&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://youngspring1.github.io/post/2016/2016-03-22-datatable3/&#34;&gt;主键、基于二分法搜索的subset&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://youngspring1.github.io/post/2016/2016-04-02-datatable4/&#34;&gt;二次索引和自动索引&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://youngspring1.github.io/post/2016/2016-04-08-datatable5/&#34;&gt;数据拆分和合并&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;原文地址：&lt;br /&gt;
&lt;a href=&#34;https://github.com/Rdatatable/data.table/wiki/Getting-started&#34;&gt;data.table/wiki/Getting-started&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;本教程讨论data.table的语义引用，它允许通过引用来add/update/delete列，然后通过参数i和by结合。它主要给那些熟悉data.table语法、知道如何subset行／select列／分组的人使用。如果你对这些不熟悉，请学习上一讲 &lt;a href=&#34;http://youngspring1.github.io/post/2016-03-13-datatable1/&#34;&gt;data.table 介绍&lt;/a&gt;。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;数据:e5b9ad2772afb60de67bb09a99ffa4e1&#34;&gt;数据&lt;/h2&gt;

&lt;p&gt;我们继续使用上一讲中使用的航班信息flights。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flights &amp;lt;- fread(&amp;quot;https://raw.githubusercontent.com/wiki/arunsrinivasan/    flights/NYCflights14/flights14.csv&amp;quot;)
flights
#         year month day dep_time dep_delay arr_time arr_delay cancelled carrier tailnum flight
#      1: 2014     1   1      914        14     1238        13         0      AA  N338AA      1
#      2: 2014     1   1     1157        -3     1523        13         0      AA  N335AA      3
#      3: 2014     1   1     1902         2     2224         9         0      AA  N327AA     21
#      4: 2014     1   1      722        -8     1014       -26         0      AA  N3EHAA     29
#      5: 2014     1   1     1347         2     1706         1         0      AA  N319AA    117
#     ---                                                                                      
# 253312: 2014    10  31     1459         1     1747       -30         0      UA  N23708   1744
# 253313: 2014    10  31      854        -5     1147       -14         0      UA  N33132   1758
# 253314: 2014    10  31     1102        -8     1311        16         0      MQ  N827MQ   3591
# 253315: 2014    10  31     1106        -4     1325        15         0      MQ  N511MQ   3592
# 253316: 2014    10  31      824        -5     1045         1         0      MQ  N813MQ   3599
#         origin dest air_time distance hour min
#      1:    JFK  LAX      359     2475    9  14
#      2:    JFK  LAX      363     2475   11  57
#      3:    JFK  LAX      351     2475   19   2
#      4:    LGA  PBI      157     1035    7  22
#      5:    JFK  LAX      350     2475   13  47
#     ---                                       
# 253312:    LGA  IAH      201     1416   14  59
# 253313:    EWR  IAH      189     1400    8  54
# 253314:    LGA  RDU       83      431   11   2
# 253315:    LGA  DTW       75      502   11   6
# 253316:    LGA  SDF      110      659    8  24
dim(flights)
# [1] 253316     17
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;介绍:e5b9ad2772afb60de67bb09a99ffa4e1&#34;&gt;介绍&lt;/h2&gt;

&lt;p&gt;在这一讲，我们会：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* 简要讨论“语义引用”，然后比较操作符“:=”的两种不同的形式。
* 学习如何在参数j里面使用操作符“:=”来add/update/delete列，如何与参数i和by相结合。
* 了解操作符“:=”的副作用，并学习如何用 copy() 来避免这些副作用。
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;1-语义引用:e5b9ad2772afb60de67bb09a99ffa4e1&#34;&gt;1. 语义引用&lt;/h2&gt;

&lt;p&gt;到目前为止，我们学习到的所有的操作都会生成一个新的数据集。接下来，我们会学习如何在原来数据集的基础上，添加／更新／删除那些已经存在的列。&lt;/p&gt;

&lt;h4 id=&#34;a-背景:e5b9ad2772afb60de67bb09a99ffa4e1&#34;&gt;a) 背景&lt;/h4&gt;

&lt;p&gt;在学习语义引用之前，我们先来看下面这个data.frame：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DF = data.frame(ID = c(&amp;quot;b&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;c&amp;quot;), a = 1:6, b = 7:12, c=13:18)
DF
#   ID a  b  c
# 1  b 1  7 13
# 2  b 2  8 14
# 3  b 3  9 15
# 4  a 4 10 16
# 5  a 5 11 17
# 6  c 6 12 18
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当我们执行下面的命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DF$c &amp;lt;- 18:13               # (1) -- replace entire column
# or
DF$c[DF$ID == &amp;quot;b&amp;quot;] &amp;lt;- 15:13 # (2) -- subassign in column &#39;c&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在R语言V3.1之前的版本里，上面这两种方法都会导致对整个data.frame的深度拷贝&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:e5b9ad2772afb60de67bb09a99ffa4e1:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:e5b9ad2772afb60de67bb09a99ffa4e1:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。而且还会拷贝多次&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:e5b9ad2772afb60de67bb09a99ffa4e1:2&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:e5b9ad2772afb60de67bb09a99ffa4e1:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;。为了提高效率避免冗余操作，data.tabel使用了操作符&amp;rdquo;:=&amp;ldquo;。R里面本来就有定义了这个操作符，但却没有使用&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:e5b9ad2772afb60de67bb09a99ffa4e1:3&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:e5b9ad2772afb60de67bb09a99ffa4e1:3&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;。&lt;br /&gt;
在R语言V3.1之前的版本里，方法(1)只做影子拷贝，处理性能有了很大提升。然而，方法(2)还是会做深度拷贝。这就意味着，对于同样的查询语句，想要选取的列越多，需要做的深度拷贝就越多。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;影子拷贝 vs 深度拷贝
影子拷贝，只是一份指向列的指针向量的拷贝，它会随着data.frame或者data.table的变化而变化。但在内存里，数据不是真的被复制了。   
深度拷贝，正相反，它会复制整个数据，并且保存在内存里。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果使用操作符&amp;rdquo;:=&amp;ldquo;，不管在R语言的什么版本里，不管是方法(1)还是方法(2)，都不会再拷贝。这是因为，操作符&amp;rdquo;:=&amp;ldquo;通过引用更新列。&lt;/p&gt;

&lt;h4 id=&#34;b-操作符:e5b9ad2772afb60de67bb09a99ffa4e1&#34;&gt;b) 操作符“:=”&lt;/h4&gt;

&lt;p&gt;在参数j中，操作符“:=”有两种使用方法：&lt;br /&gt;
a.左右等式的形式&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DT[, c(&amp;quot;colA&amp;quot;, &amp;quot;colB&amp;quot;, ...) := list(valA, valB, ...)]

# when you have only one column to assign to you 
# can drop the quotes and list(), for convenience
DT[, colA := valA]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;b.函数形式&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DT[, `:=`(colA = valA, # valA is assigned to colA
      colB = valB, # valB is assigned to colB
      ...
)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;上面的两个例子只是用来说明使用的形式，并不是实际可以运行的代码示例。我们会在下一节中，用航班信息flight的data.table来举例说明。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* 形式(a)比较容易编码，特别是，事先不知道需要被赋值的列的时候。
* 相对而言，形式(b)更加趁手，如果你愿意追加点注释😄。
* 操作符“:=”没有返回值。
* 既然参数j里面可以使用操作符“:=”，那么，就像上一讲中学习到的内容，我们可以和参数i和参数by一起，做些聚合的运算。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上面两种形式里，注意我们没有把运算的结果赋值给一个变量。因为完全没必要。我们直接更新data.table。让我们通过一些例子来说明。&lt;br /&gt;
在接下来的教程里，我们对航班信息flight，这个data.table来示例。&lt;/p&gt;

&lt;h2 id=&#34;2-添加-更新-删除列:e5b9ad2772afb60de67bb09a99ffa4e1&#34;&gt;2. 添加／更新／删除列&lt;/h2&gt;

&lt;h4 id=&#34;a-添加列:e5b9ad2772afb60de67bb09a99ffa4e1&#34;&gt;a) 添加列&lt;/h4&gt;

&lt;p&gt;－如何对每次航班，添加 speed 和 total delay 两列&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flights[, `:=`(speed = distance / (air_time/60), # speed in km/hr
           delay = arr_delay + dep_delay)]       # delay in minutes
head(flights)
#    year month day dep_time dep_delay arr_time arr_delay cancelled carrier tailnum flight origin
# 1: 2014     1   1      914        14     1238        13         0      AA  N338AA      1    JFK
# 2: 2014     1   1     1157        -3     1523        13         0      AA  N335AA      3    JFK
# 3: 2014     1   1     1902         2     2224         9         0      AA  N327AA     21    JFK
# 4: 2014     1   1      722        -8     1014       -26         0      AA  N3EHAA     29    LGA
# 5: 2014     1   1     1347         2     1706         1         0      AA  N319AA    117    JFK
# 6: 2014     1   1     1824         4     2145         0         0      AA  N3DEAA    119    EWR
#    dest air_time distance hour min    speed delay
# 1:  LAX      359     2475    9  14 413.6490    27
# 2:  LAX      363     2475   11  57 409.0909    10
# 3:  LAX      351     2475   19   2 423.0769    11
# 4:  PBI      157     1035    7  22 395.5414   -34
# 5:  LAX      350     2475   13  47 424.2857     3
# 6:  LAX      339     2454   18  24 434.3363     4

## alternatively, using the &#39;LHS := RHS&#39; form
# flights[, c(&amp;quot;speed&amp;quot;, &amp;quot;delay&amp;quot;) := list(distance/(air_time/60), arr_delay + dep_delay)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* 我们不需要将结果赋值给 flights。
* flights 现在包含了刚刚追加的两列。这就是我们说的“添加列”。
* 我们用函数形式，这样就可以在旁边写注释了。当然也可以用等式的形式。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;b-更新列-sub-assign:e5b9ad2772afb60de67bb09a99ffa4e1&#34;&gt;b) 更新列（sub-assign）&lt;/h4&gt;

&lt;p&gt;现在留意一下 fligths 里的 hour列。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# get all &#39;hours&#39; in flights
flights[, sort(unique(hour))]
#  [1]  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，hour列有25种不同的取值。但是0点和24点应该是一样的，我们来把24点全部替换成0点。&lt;br /&gt;
－将 hour=24 替换成0&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# subassign by reference
flights[hour == 24L, hour := 0L]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* 就像在上一讲中学习的一样，我们可以使用参数i 和 参数j里的操作符“:=”一起使用。
* 只有满足了参数i 中指定的条件 hour == 24L 的那些列，它们的值会被替换成0。
* 操作符“:=”没有返回值。有时候需要查看运行的结果，我们可以在查询语句的最后加一对方括号[]，来达到这个目的。
flights[hour == 24L, hour := 0L][]
#         year month day dep_time dep_delay arr_time arr_delay cancelled carrier tailnum flight
#      1: 2014     1   1      914        14     1238        13         0      AA  N338AA      1
#      2: 2014     1   1     1157        -3     1523        13         0      AA  N335AA      3
#      3: 2014     1   1     1902         2     2224         9         0      AA  N327AA     21
#      4: 2014     1   1      722        -8     1014       -26         0      AA  N3EHAA     29
#      5: 2014     1   1     1347         2     1706         1         0      AA  N319AA    117
#     ---                                                                                      
# 253312: 2014    10  31     1459         1     1747       -30         0      UA  N23708   1744
# 253313: 2014    10  31      854        -5     1147       -14         0      UA  N33132   1758
# 253314: 2014    10  31     1102        -8     1311        16         0      MQ  N827MQ   3591
# 253315: 2014    10  31     1106        -4     1325        15         0      MQ  N511MQ   3592
# 253316: 2014    10  31      824        -5     1045         1         0      MQ  N813MQ   3599
#         origin dest air_time distance hour min    speed delay
#      1:    JFK  LAX      359     2475    9  14 413.6490    27
#      2:    JFK  LAX      363     2475   11  57 409.0909    10
#      3:    JFK  LAX      351     2475   19   2 423.0769    11
#      4:    LGA  PBI      157     1035    7  22 395.5414   -34
#      5:    JFK  LAX      350     2475   13  47 424.2857     3
#     ---                                                      
# 253312:    LGA  IAH      201     1416   14  59 422.6866   -29
# 253313:    EWR  IAH      189     1400    8  54 444.4444   -19
# 253314:    LGA  RDU       83      431   11   2 311.5663     8
# 253315:    LGA  DTW       75      502   11   6 401.6000    11
# 253316:    LGA  SDF      110      659    8  24 359.4545    -4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在我们再来看下 hour列。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# check again for &#39;24&#39;
flights[, sort(unique(hour))]
#  [1]  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;c-删除列:e5b9ad2772afb60de67bb09a99ffa4e1&#34;&gt;c) 删除列&lt;/h4&gt;

&lt;p&gt;－删除 delay列&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flights[, c(&amp;quot;delay&amp;quot;) := NULL]
head(flights)
#    year month day dep_time dep_delay arr_time arr_delay cancelled carrier tailnum flight origin
# 1: 2014     1   1      914        14     1238        13         0      AA  N338AA      1    JFK
# 2: 2014     1   1     1157        -3     1523        13         0      AA  N335AA      3    JFK
# 3: 2014     1   1     1902         2     2224         9         0      AA  N327AA     21    JFK
# 4: 2014     1   1      722        -8     1014       -26         0      AA  N3EHAA     29    LGA
# 5: 2014     1   1     1347         2     1706         1         0      AA  N319AA    117    JFK
# 6: 2014     1   1     1824         4     2145         0         0      AA  N3DEAA    119    EWR
#    dest air_time distance hour min    speed
# 1:  LAX      359     2475    9  14 413.6490
# 2:  LAX      363     2475   11  57 409.0909
# 3:  LAX      351     2475   19   2 423.0769
# 4:  PBI      157     1035    7  22 395.5414
# 5:  LAX      350     2475   13  47 424.2857
# 6:  LAX      339     2454   18  24 434.3363

## or using the functional form
# flights[, `:=`(delay = NULL)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* 将一列赋值为 NULL，就会删除那一列。删除立即生效。
* 使用左右等式的形式的时候，除了指定列名，我们也可以指定列号。但还是忘记吧，指定列名是个好的编码习惯。
* 为了方便，如果只需要删除一列，可以去掉 c(&amp;quot;&amp;quot;)，只指定列名，像这样：
flights[, delay := NULL]
这和上面的方法是等效的。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;d-和分组:e5b9ad2772afb60de67bb09a99ffa4e1&#34;&gt;d) “:=”和分组&lt;/h4&gt;

&lt;p&gt;我们已经在b)里面学习了如何跟参数i 一起使用，现在我们来学习如何跟参数by 一起使用。
－如何追加一列，用来保存某对起飞／到达机场间的最快飞行速度&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flights[, max_speed := max(speed), by=.(origin, dest)]
head(flights)
#    year month day dep_time dep_delay arr_time arr_delay cancelled carrier tailnum flight origin
# 1: 2014     1   1      914        14     1238        13         0      AA  N338AA      1    JFK
# 2: 2014     1   1     1157        -3     1523        13         0      AA  N335AA      3    JFK
# 3: 2014     1   1     1902         2     2224         9         0      AA  N327AA     21    JFK
# 4: 2014     1   1      722        -8     1014       -26         0      AA  N3EHAA     29    LGA
# 5: 2014     1   1     1347         2     1706         1         0      AA  N319AA    117    JFK
# 6: 2014     1   1     1824         4     2145         0         0      AA  N3DEAA    119    EWR
#    dest air_time distance hour min    speed max_speed
# 1:  LAX      359     2475    9  14 413.6490  526.5957
# 2:  LAX      363     2475   11  57 409.0909  526.5957
# 3:  LAX      351     2475   19   2 423.0769  526.5957
# 4:  PBI      157     1035    7  22 395.5414  517.5000
# 5:  LAX      350     2475   13  47 424.2857  526.5957
# 6:  LAX      339     2454   18  24 434.3363  518.4507
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* 我们用操作符“:=”追加了一列 max_speed。
* 和上一讲学习到的内容一样，我们将所有数据进行分组。对于每组数据，计算最快速度。对于一对机场，这个最快速度是唯一的。循环复制这个值到一个list，直到跟该组数据的行数一样多。航班信息flights会被就地更新，不会因拷贝浪费内存空间。
* 和上一讲学习到的内容一样，我们也可以对参数by指定一个字符型的向量，形式是这样：
by = c(&amp;quot;origin&amp;quot;, &amp;quot;dest&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;e-和复数列:e5b9ad2772afb60de67bb09a99ffa4e1&#34;&gt;e) “:=”和复数列&lt;/h4&gt;

&lt;p&gt;－如何再追加两列，用于保存每个月的最大起飞延误时间dep_delay 和到达延误时间arr_delay&lt;br /&gt;
小提示：要用到上一讲学习到的 .SD&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;in_cols  = c(&amp;quot;dep_delay&amp;quot;, &amp;quot;arr_delay&amp;quot;)
out_cols = c(&amp;quot;max_dep_delay&amp;quot;, &amp;quot;max_arr_delay&amp;quot;)
flights[, c(out_cols) := lapply(.SD, max), by = month, .SDcols = in_cols]
head(flights)
#    year month day dep_time dep_delay arr_time arr_delay cancelled carrier tailnum flight origin
# 1: 2014     1   1      914        14     1238        13         0      AA  N338AA      1    JFK
# 2: 2014     1   1     1157        -3     1523        13         0      AA  N335AA      3    JFK
# 3: 2014     1   1     1902         2     2224         9         0      AA  N327AA     21    JFK
# 4: 2014     1   1      722        -8     1014       -26         0      AA  N3EHAA     29    LGA
# 5: 2014     1   1     1347         2     1706         1         0      AA  N319AA    117    JFK
# 6: 2014     1   1     1824         4     2145         0         0      AA  N3DEAA    119    EWR
#    dest air_time distance hour min    speed max_speed max_dep_delay max_arr_delay
# 1:  LAX      359     2475    9  14 413.6490  526.5957           973           996
# 2:  LAX      363     2475   11  57 409.0909  526.5957           973           996
# 3:  LAX      351     2475   19   2 423.0769  526.5957           973           996
# 4:  PBI      157     1035    7  22 395.5414  517.5000           973           996
# 5:  LAX      350     2475   13  47 424.2857  526.5957           973           996
# 6:  LAX      339     2454   18  24 434.3363  518.4507           973           996
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* 为了更好的可读性，我们使用了左右等式的形式。我们事先保存了输入的列名到变量in_cols，作为 .SDcols的参数。我们还事先保存了输出的列名到变量out_cols，作为左边的表达式。
* 注意一下，我们在c)里面讲过，如果只需要追加一列，那么可以省略双引号，只指定列名。但是这里我们需要指定 c(out_cols) 或者 (out_cols)。 
* 左右等式的形式，允许我们操作复数的列。在右边的表达式里，为了对指定在 .SDcols 里的列计算最大值，我们使用了R的基础函数 lapply()。这些我们在上一讲中都学习过了。它返回有两个元素的list，包含每组的 dep_delay 和 arr_delay 这两列的最大值。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在进行下一节的学习之前，让我们删除刚刚追加的几列：speed, max_speed, max_dep_delay 和 max_arr_delay。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# RHS gets automatically recycled to length of LHS
flights[, c(&amp;quot;speed&amp;quot;, &amp;quot;max_speed&amp;quot;, &amp;quot;max_dep_delay&amp;quot;, &amp;quot;max_arr_delay&amp;quot;) := NULL]
head(flights)
#    year month day dep_time dep_delay arr_time arr_delay cancelled carrier tailnum flight origin
# 1: 2014     1   1      914        14     1238        13         0      AA  N338AA      1    JFK
# 2: 2014     1   1     1157        -3     1523        13         0      AA  N335AA      3    JFK
# 3: 2014     1   1     1902         2     2224         9         0      AA  N327AA     21    JFK
# 4: 2014     1   1      722        -8     1014       -26         0      AA  N3EHAA     29    LGA
# 5: 2014     1   1     1347         2     1706         1         0      AA  N319AA    117    JFK
# 6: 2014     1   1     1824         4     2145         0         0      AA  N3DEAA    119    EWR
#    dest air_time distance hour min
# 1:  LAX      359     2475    9  14
# 2:  LAX      363     2475   11  57
# 3:  LAX      351     2475   19   2
# 4:  PBI      157     1035    7  22
# 5:  LAX      350     2475   13  47
# 6:  LAX      339     2454   18  24
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3-和copy:e5b9ad2772afb60de67bb09a99ffa4e1&#34;&gt;3. “:=”和copy()&lt;/h2&gt;

&lt;p&gt;操作符“:=”会更新原数据。和我们之前学过的功能不同，有时候，我们希望更新原数据。但有时候，我们不想更新原数据，这种情况下，我们可以用函数 copy()。&lt;/p&gt;

&lt;h4 id=&#34;a-的副作用:e5b9ad2772afb60de67bb09a99ffa4e1&#34;&gt;a) “:=”的副作用&lt;/h4&gt;

&lt;p&gt;如果我们想创建一个函数，用于返回每个月的最快速度。但是此时，我们也想对 flights 追加一列 speed。可以像下面这样做：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;foo &amp;lt;- function(DT) {
  DT[, speed := distance / (air_time/60)]
  DT[, .(max_speed = max(speed)), by=month]
}
ans = foo(flights)
head(flights)
#    year month day dep_time dep_delay arr_time arr_delay cancelled carrier tailnum flight origin
# 1: 2014     1   1      914        14     1238        13         0      AA  N338AA      1    JFK
# 2: 2014     1   1     1157        -3     1523        13         0      AA  N335AA      3    JFK
# 3: 2014     1   1     1902         2     2224         9         0      AA  N327AA     21    JFK
# 4: 2014     1   1      722        -8     1014       -26         0      AA  N3EHAA     29    LGA
# 5: 2014     1   1     1347         2     1706         1         0      AA  N319AA    117    JFK
# 6: 2014     1   1     1824         4     2145         0         0      AA  N3DEAA    119    EWR
#    dest air_time distance hour min    speed
# 1:  LAX      359     2475    9  14 413.6490
# 2:  LAX      363     2475   11  57 409.0909
# 3:  LAX      351     2475   19   2 423.0769
# 4:  PBI      157     1035    7  22 395.5414
# 5:  LAX      350     2475   13  47 424.2857
# 6:  LAX      339     2454   18  24 434.3363
head(ans)
#    month max_speed
# 1:     1  535.6425
# 2:     2  535.6425
# 3:     3  549.0756
# 4:     4  585.6000
# 5:     5  544.2857
# 6:     6  608.5714
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* 注意一个新的列 speed 被追加到 flight 里了。这时因为我们用了操作符“:=”。既然 DT 和flights都指向内存中同一个对象，对 DT 的操作，也会对 flights 生效。
* 返回值 ans 包含了每月的最快速度。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;b-函数copy:e5b9ad2772afb60de67bb09a99ffa4e1&#34;&gt;b) 函数copy()&lt;/h4&gt;

&lt;p&gt;在前面一节，我们利用了操作符“:=”的副作用来更新原数据。但是不会一直希望这样又是，我们希望给函数传递data.table参数，使用操作符“:=”的功能，但是不想改变原数据。我们可以用函数 copy() 来做到这一点。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;函数 copy() 对输入参数进行深度拷贝，因此对副本做的所有更新操作，都不会对原数据生效。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;函数 copy() 有两个不可或缺的特点：&lt;br /&gt;
1.和前一节内容的情形相反，我们可能不希望传递的参数被修改。举个例子，考虑前一节中，我们不想修改 flights的内容。&lt;br /&gt;
我们先删掉前一节中，追加的 speed列：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flights[, speed := NULL]   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在，我们可以像下面这样做：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;foo &amp;lt;- function(DT) {
  DT &amp;lt;- copy(DT)                             ## deep copy
  DT[, speed := distance / (air_time/60)]    ## doesn&#39;t affect &#39;flights&#39;
  DT[, .(max_speed = max(speed)), by=month]
}
ans &amp;lt;- foo(flights)
head(flights)
#    year month day dep_time dep_delay arr_time arr_delay cancelled carrier tailnum flight origin
# 1: 2014     1   1      914        14     1238        13         0      AA  N338AA      1    JFK
# 2: 2014     1   1     1157        -3     1523        13         0      AA  N335AA      3    JFK
# 3: 2014     1   1     1902         2     2224         9         0      AA  N327AA     21    JFK
# 4: 2014     1   1      722        -8     1014       -26         0      AA  N3EHAA     29    LGA
# 5: 2014     1   1     1347         2     1706         1         0      AA  N319AA    117    JFK
# 6: 2014     1   1     1824         4     2145         0         0      AA  N3DEAA    119    EWR
#    dest air_time distance hour min
# 1:  LAX      359     2475    9  14
# 2:  LAX      363     2475   11  57
# 3:  LAX      351     2475   19   2
# 4:  PBI      157     1035    7  22
# 5:  LAX      350     2475   13  47
# 6:  LAX      339     2454   18  24
head(ans)
#    month max_speed
# 1:     1  535.6425
# 2:     2  535.6425
# 3:     3  549.0756
# 4:     4  585.6000
# 5:     5  544.2857
# 6:     6  608.5714
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* 使用函数 copy() 不会更新 flights。它现在不包含 speed列。
* 返回值 ans 包含了每月的最快速度。
然而，我们可以使用影子拷贝来代替深度拷贝，来大幅度提高这个操作的效率。事实上，我们希望在 Data.Table的V1.9.8的版本里提供这个功能。我们会在data.table的设计里面继续讨论这个内容。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Data.Table V1.9.8 相关资料：&lt;br /&gt;
&lt;a href=&#34;https://github.com/Rdatatable/data.table/issues/617&#34;&gt;Copy-on-:= at column level, DT[,list(&amp;hellip;)] shallow copy and add cols to shallow(DT, cols)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2.当我们将列名保存在变量里的时候，比如：DT_n = names(DT)，然后再对 DT 添加／更新／删除列，操作符“:=”也会更新变量 DT_n，除非我们运行 copy(names(DT))。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DT = data.table(x=1, y=2)
DT_n = names(DT)
DT_n
# [1] &amp;quot;x&amp;quot; &amp;quot;y&amp;quot;

## add a new column by reference
DT[, z := 3]

## DT_n also gets updated
DT_n
# [1] &amp;quot;x&amp;quot; &amp;quot;y&amp;quot; &amp;quot;z&amp;quot;

## use `copy()`
DT_n = copy(names(DT))
DT[, w := 4]

## DT_n doesn&#39;t get updated
DT_n
# [1] &amp;quot;x&amp;quot; &amp;quot;y&amp;quot; &amp;quot;z&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;总结:e5b9ad2772afb60de67bb09a99ffa4e1&#34;&gt;总结&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;操作符“:=”
* 操作符“:=”用于添加／更新／删除列。
* 我们也学习了如何跟参数i和参数by一起使用，就像在第一讲中学习的那样。同样，我们也可以使用 keyby，可以用方括号 [] 将操作连结起来，可以给参数by 指定表达式。
* 我们可以利用操作符“:=”更新原数据，也可以用函数 copy() 来避免更新原数据。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;到目前为止，我们学习了好多参数j相关的知识，知道了参数i、参数j和参数by如何一起使用。下一讲&lt;a href=&#34;http://youngspring1.github.io/post/2016-03-22-datatable3/&#34;&gt;主键、基于二分法搜索的subset&lt;/a&gt;，我们将注意力回到参数i上，来做一些通过主键的超快速的排序。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:e5b9ad2772afb60de67bb09a99ffa4e1:1&#34;&gt;&lt;a href=&#34;http://r.789695.n4.nabble.com/speeding-up-perception-td3640920.html#a3646694&#34;&gt;Speeding up perception&lt;/a&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:e5b9ad2772afb60de67bb09a99ffa4e1:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:e5b9ad2772afb60de67bb09a99ffa4e1:2&#34;&gt;&lt;a href=&#34;http://stackoverflow.com/questions/23898969/is-data-really-copied-four-times-in-rs-replacement-functions&#34;&gt;Is data really copied four times in R&amp;rsquo;s replacement functions?&lt;/a&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:e5b9ad2772afb60de67bb09a99ffa4e1:2&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:e5b9ad2772afb60de67bb09a99ffa4e1:3&#34;&gt;&lt;a href=&#34;http://stackoverflow.com/questions/7033106/why-has-data-table-defined-rather-than-overloading&#34;&gt;Why has data.table defined := rather than overloading &amp;lt;-?&lt;/a&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:e5b9ad2772afb60de67bb09a99ffa4e1:3&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>data.table 教程1－data.table 介绍</title>
      <link>http://youngspring1.github.io/post/2016/2016-03-13-datatable1/</link>
      <pubDate>Sun, 13 Mar 2016 18:57:40 +0800</pubDate>
      
      <guid>http://youngspring1.github.io/post/2016/2016-03-13-datatable1/</guid>
      <description>

&lt;p&gt;最近使用data.table这个增强包，来计算数据的聚合信息，比sql语句简单明了不是一点半点，于是想把data.table的资料翻译出来。&lt;/p&gt;

&lt;p&gt;目录：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://youngspring1.github.io/post/2016/2016-03-13-datatable1/&#34;&gt;data.table 介绍&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://youngspring1.github.io/post/2016/2016-03-21-datatable2/&#34;&gt;语义引用&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://youngspring1.github.io/post/2016/2016-03-22-datatable3/&#34;&gt;主键、基于二分法搜索的subset&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://youngspring1.github.io/post/2016/2016-04-02-datatable4/&#34;&gt;二次索引和自动索引&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://youngspring1.github.io/post/2016/2016-04-08-datatable5/&#34;&gt;数据拆分和合并&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;原文地址：&lt;br /&gt;
&lt;a href=&#34;https://github.com/Rdatatable/data.table/wiki/Getting-started&#34;&gt;data.table/wiki/Getting-started&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;注：subset特指对列的选择，select特指对行的选择。这两个单词在中文里没有确切并且简洁的词，所以直接使用不作翻译。后面有类似用原文的也同样直接使用英文。&lt;/p&gt;

&lt;p&gt;本教程介绍data.table的语法，大概的形式，如何对行进行select，如何对列进行subset和compute，如何分组聚合。熟悉data.frame的数据结构是有帮助的，不过不熟悉也没关系。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;使用data-table分析数据:3d5b18c834d19c525ed890cfd64b400c&#34;&gt;使用data.table分析数据&lt;/h2&gt;

&lt;p&gt;操作数据的功能，例如subset、group、update、join等都有内在的关联。&lt;br /&gt;
保持这些关联的操作可以：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* 通过简洁一致的语法，实行想要的操作，达到目的。
* 从一系列函数到最终的分析，都没有将所有的操作都对应到函数的负担。能够流畅地执行分析。
* 精确地知道每步操作所需要的数据，内部自动优化操作，在运行速度和内存开销两方面都很有效果。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;简要的讲，如果你对减小计算复杂度和计算时间有着迫切的需求，那么这个package就是为你量身打造的。data.table被设计出来就是为了完成这样的事情。我们通过这一系列教程，说明这些功能。&lt;/p&gt;

&lt;h2 id=&#34;数据:3d5b18c834d19c525ed890cfd64b400c&#34;&gt;数据&lt;/h2&gt;

&lt;p&gt;在这个教程中，我们使用&lt;a href=&#34;https://github.com/arunsrinivasan/flights/wiki/NYC-Flights-2014-data&#34;&gt;NYC-flights14&lt;/a&gt;的数据。它包含了2014年纽约机场发出的所有航班信息。这份数据只有2014年1月到10月是公开的。&lt;br /&gt;
我们可以使用data.table的fread()函数，用下面的方式，快速直接读取航班数据：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flights &amp;lt;- fread(&amp;quot;https://raw.githubusercontent.com/wiki/arunsrinivasan/    flights/NYCflights14/flights14.csv&amp;quot;)
flights
#         year month day dep_time dep_delay arr_time arr_delay cancelled carrier tailnum flight
#      1: 2014     1   1      914        14     1238        13         0      AA  N338AA      1
#      2: 2014     1   1     1157        -3     1523        13         0      AA  N335AA      3
#      3: 2014     1   1     1902         2     2224         9         0      AA  N327AA     21
#      4: 2014     1   1      722        -8     1014       -26         0      AA  N3EHAA     29
#      5: 2014     1   1     1347         2     1706         1         0      AA  N319AA    117
#     ---                                                                                      
# 253312: 2014    10  31     1459         1     1747       -30         0      UA  N23708   1744
# 253313: 2014    10  31      854        -5     1147       -14         0      UA  N33132   1758
# 253314: 2014    10  31     1102        -8     1311        16         0      MQ  N827MQ   3591
# 253315: 2014    10  31     1106        -4     1325        15         0      MQ  N511MQ   3592
# 253316: 2014    10  31      824        -5     1045         1         0      MQ  N813MQ   3599
#         origin dest air_time distance hour min
#      1:    JFK  LAX      359     2475    9  14
#      2:    JFK  LAX      363     2475   11  57
#      3:    JFK  LAX      351     2475   19   2
#      4:    LGA  PBI      157     1035    7  22
#      5:    JFK  LAX      350     2475   13  47
#     ---                                       
# 253312:    LGA  IAH      201     1416   14  59
# 253313:    EWR  IAH      189     1400    8  54
# 253314:    LGA  RDU       83      431   11   2
# 253315:    LGA  DTW       75      502   11   6
# 253316:    LGA  SDF      110      659    8  24
dim(flights)
# [1] 253316     17
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;既然整个教程我们都会使用这份数据，那你不妨先下载到你的电脑上，然后每次使用的时候再读取。&lt;/p&gt;

&lt;h2 id=&#34;介绍:3d5b18c834d19c525ed890cfd64b400c&#34;&gt;介绍&lt;/h2&gt;

&lt;p&gt;在本章中，我们会学习下面两点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;基础 － 什么是data.table，它的形式，如何subset行，如何select列，如何按列进行运算。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;聚合 － 按组聚合的效果。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;1-基础:3d5b18c834d19c525ed890cfd64b400c&#34;&gt;1.基础&lt;/h2&gt;

&lt;h4 id=&#34;a-什么是data-table:3d5b18c834d19c525ed890cfd64b400c&#34;&gt;a) 什么是data.table&lt;/h4&gt;

&lt;p&gt;data.table是R语言的一个包，它是对data.frames的增强。在上文（读取航班）“数据”的部分，我们通过函数fread()创建了一个data.table。我们也可以通过函数data.table()创建一个data.table，比如这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DT = data.table(ID = c(&amp;quot;b&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;c&amp;quot;), a = 1:6, b = 7:12, c=13:18)
DT
#    ID a  b  c
# 1:  b 1  7 13
# 2:  b 2  8 14
# 3:  b 3  9 15
# 4:  a 4 10 16
# 5:  a 5 11 17
# 6:  c 6 12 18
class(DT$ID)
# [1] &amp;quot;character&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们也可以通过as.data.table()将已经存在的对象转化成data.table。&lt;/p&gt;

&lt;p&gt;注意：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;不同于data.frames，字符型的列，不会被自动转化成因子。&lt;/li&gt;
&lt;li&gt;行号后面有个冒号，用于隔开第一列的内容。&lt;/li&gt;
&lt;li&gt;如果数据的条目超过了全局选项datatable.print.nrows所定义的数值（默认是100条），那么只会输出数据最开头和最末尾的5行。就如同上文（读取航班）“数据”的部分。&lt;br /&gt;
&lt;code&gt;getOption(&amp;quot;datatable.print.nrows&amp;quot;)&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;# [1] 100&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;data.table不能设置行的名称。我们会在第三讲中说明原因。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;b-形式-data-table增强了什么:3d5b18c834d19c525ed890cfd64b400c&#34;&gt;b) 形式－data.table增强了什么&lt;/h4&gt;

&lt;p&gt;和data.frame相反，我们能做的可不仅仅局限于subset行或者select列。首先介绍下data.table的语法，如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DT[i, j, by]

##   R:      i                 j        by
## SQL:  where   select | update  group by
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你有SQL语句的基础，那么你应该能马上明白data.table的语法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;语法是：
对于DT这个data.table，使用 i 来subset行，然后计算 j ，最后用 by 分组。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;c-subset行:3d5b18c834d19c525ed890cfd64b400c&#34;&gt;c) subset行&lt;/h4&gt;

&lt;p&gt;－ 获取六月份所有从&amp;rdquo;JFK&amp;rdquo;机场起飞的航班&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ans &amp;lt;- flights[origin == &amp;quot;JFK&amp;quot; &amp;amp; month == 6L]
head(ans)
#    year month day dep_time dep_delay arr_time arr_delay cancelled carrier tailnum flight origin
# 1: 2014     6   1      851        -9     1205        -5         0      AA  N787AA      1    JFK
# 2: 2014     6   1     1220       -10     1522       -13         0      AA  N795AA      3    JFK
# 3: 2014     6   1      718        18     1014        -1         0      AA  N784AA      9    JFK
# 4: 2014     6   1     1024        -6     1314       -16         0      AA  N791AA     19    JFK
# 5: 2014     6   1     1841        -4     2125       -45         0      AA  N790AA     21    JFK
# 6: 2014     6   1     1454        -6     1757       -23         0      AA  N785AA    117    JFK
#    dest air_time distance hour min
# 1:  LAX      324     2475    8  51
# 2:  LAX      329     2475   12  20
# 3:  LAX      326     2475    7  18
# 4:  LAX      320     2475   10  24
# 5:  LAX      326     2475   18  41
# 6:  LAX      329     2475   14  54
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* 通过data.frame的frame？，列可以像变量一样被引用。因此，我们不需要加上 flights$ 前缀，比如 flights$dest 和 flights$month，而是直接简单地引用 dest 和 month这两列。
* 满足 origin == &amp;quot;JFK&amp;quot; &amp;amp; month == 6L 这两个条件的行会被抽出出来。既然我们没有指定其他的条件，一个包含原数据里面所有列的data.table会被返回。
* 语法里面[i,j,k]的逗号不是必须的，当然如果指定了逗号，比如 flights[dest == &amp;quot;JFK&amp;quot; &amp;amp; month == 6L, ] 也是没问题的。但在data.frame里面，逗号却是必须的。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;－ 获取 flights 开头的两行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ans &amp;lt;- flights[1:2]
ans
#    year month day dep_time dep_delay arr_time arr_delay cancelled carrier tailnum flight origin
# 1: 2014     1   1      914        14     1238        13         0      AA  N338AA      1    JFK
# 2: 2014     1   1     1157        -3     1523        13         0      AA  N335AA      3    JFK
#    dest air_time distance hour min
# 1:  LAX      359     2475    9  14
# 2:  LAX      363     2475   11  57
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* 我们没有指定任何条件。行的索引已经自动提供给参数 i 了。因此，我们得到一个包含原数据 flight 里所有列的data.table（for 这些行的索引？）。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;－ 排序（先按 origin列 的升序，再按 dest 的降序排列）
我们可以通过R语言的基础函数 order() 来完成这个功能。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ans &amp;lt;- flights[order(origin, -dest)]
head(ans)
#    year month day dep_time dep_delay arr_time arr_delay cancelled carrier tailnum flight origin
# 1: 2014     1   5      836         6     1151        49         0      EV  N12175   4419    EWR
# 2: 2014     1   6      833         7     1111        13         0      EV  N24128   4419    EWR
# 3: 2014     1   7      811        -6     1035       -13         0      EV  N12142   4419    EWR
# 4: 2014     1   8      810        -7     1036       -12         0      EV  N11193   4419    EWR
# 5: 2014     1   9      833        16     1055         7         0      EV  N14198   4419    EWR
# 6: 2014     1  13      923        66     1154        66         0      EV  N12157   4419    EWR
#    dest air_time distance hour min
# 1:  XNA      195     1131    8  36
# 2:  XNA      190     1131    8  33
# 3:  XNA      179     1131    8  11
# 4:  XNA      184     1131    8  10
# 5:  XNA      181     1131    8  33
# 6:  XNA      188     1131    9  23
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;内置的 order() 函数
* 我们可以对一个字符型的列，使用减号“-”，来实现降序排列。
* 另外，函数 order() 其实调用了data.table的快速基数排序函数 forder()，它比 base::order 快很多。这是一个说明它们基本区别的例子：

odt = data.table(col=sample(1e7))
(t1 &amp;lt;- system.time(ans1 &amp;lt;- odt[base::order(col)]))  ## uses order from base R
#    user  system elapsed 
#   8.610   0.056   8.708
(t2 &amp;lt;- system.time(ans2 &amp;lt;- odt[order(col)]))        ## uses data.table&#39;s forder
#    user  system elapsed 
#   0.526   0.024   0.553
(identical(ans1, ans2))
# [1] TRUE

order() 比 base::order 大约快了16倍。我们会在data.table的内部教程中讨论data.table快速排序的更多细节。
* 因此，使用我们熟悉的函数，就可以显著地提高分析效率。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;d-select列:3d5b18c834d19c525ed890cfd64b400c&#34;&gt;d) select列&lt;/h4&gt;

&lt;p&gt;－ 选取 arr_delay 列，返回值是向量&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ans &amp;lt;- flights[, arr_delay]
head(ans)
# [1]  13  13   9 -26   1   0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* 既然列可以作为变量被引用，我们可以直接引用我们想选取的列。
* 既然我们想选取所有的行，我们毋需指定参数 i。
* 返回了所有行的 arr_delay 列。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;－ 选取 arr_delay 列，返回值是data.table&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ans &amp;lt;- flights[, list(arr_delay)]
head(ans)
#    arr_delay
# 1:        13
# 2:        13
# 3:         9
# 4:       -26
# 5:         1
# 6:         0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* 我们用 list() 把列名 arr_delay 包围起来，它可以确保返回值是data.table。正如前面一个例子，如果不这样做，返回值就是一个向量。
* data.table也允许用 .() 来包围列名，它是 list() 的别名，它们的效果是同样的。教程后面会使用 .() 来说明。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;只要参数 j 返回一个list，这个list的每一个元素都会被转换成结果data.table的一列。你马上就会发现，这个功能是多么强大。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;－ 选取 arr_delay 列和 dep_delay 列&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ans &amp;lt;- flights[, .(arr_delay, dep_delay)]
head(ans)
#    arr_delay dep_delay
# 1:        13        14
# 2:        13        -3
# 3:         9         2
# 4:       -26        -8
# 5:         1         2
# 6:         0         4

## alternatively
# ans &amp;lt;- flights[, list(arr_delay, dep_delay)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* 使用 .() 或者 list() 都可以。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;－ 选取 arr_delay 列和 dep_delay 列，并把列名改为 delay_arr 和 delay_dep
既然 .() 是 list() 的别名，那么我们可以在创建 list 的时候对列命名。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ans &amp;lt;- flights[, .(delay_arr = arr_delay, delay_dep = dep_delay)]
head(ans)
#    delay_arr delay_dep
# 1:        13        14
# 2:        13        -3
# 3:         9         2
# 4:       -26        -8
# 5:         1         2
# 6:         0         4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就是这样。&lt;/p&gt;

&lt;h4 id=&#34;e-在参数j里运算:3d5b18c834d19c525ed890cfd64b400c&#34;&gt;e) 在参数j里运算&lt;/h4&gt;

&lt;p&gt;－ 有多少航班完全没有延误&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ans &amp;lt;- flights[, sum((arr_delay + dep_delay) &amp;lt; 0)]
ans
# [1] 141814
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;刚刚发生了什么？
* 参数 j 能做的，可不只是选取列这么简单，它能处理表达式，比如对列进行计算。这没什么大惊小怪的，因为列可以作为变量被引用嘛。所以，我们可以对这些变量调用函数。我们刚刚就是对两列求和(sum)了。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;f-在参数i里选取-在参数j里运算:3d5b18c834d19c525ed890cfd64b400c&#34;&gt;f) 在参数i里选取，在参数j里运算&lt;/h4&gt;

&lt;p&gt;－ 在六月份，从&amp;rdquo;JFK&amp;rdquo;机场起飞的航班中，计算起飞和到达的平均延误时间&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ans &amp;lt;- flights[origin == &amp;quot;JFK&amp;quot; &amp;amp; month == 6L, 
           .(m_arr=mean(arr_delay), m_dep=mean(dep_delay))]
ans
#       m_arr    m_dep
# 1: 5.839349 9.807884
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* 我们首先在i参数里，找到所有符合 origin (机场)是&amp;quot;JFK&amp;quot;，并且 month (月份)是 6 这样条件的行。此时，我们还没有subset整个data.table。
* 现在，我们看看参数j，它只使用了两列。我们需要分别计算这两列的平均值 mean()。这个时候，我们才subset那些符合i参数里条件的列，然后计算它们的平均值。
因为这三个参数（i，j和by）都被指定在同一个方括号中，data.table能同时接受这三个参数，并在计算之前，选取最优的计算方法，而不是分步骤计算。所以，我们可以避免对整个data.table计算，同时，在计算速度和内存使用量这两方面，取得最优的效果。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;－ 在六月份，从&amp;rdquo;JFK&amp;rdquo;机场起飞的航班一共有多少&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ans &amp;lt;- flights[origin == &amp;quot;JFK&amp;quot; &amp;amp; month == 6L, length(dest)]
ans
# [1] 8422
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;函数 length() 需要一个参数。我们只需要知道，结果里有多少行数据。我们可以使用任何一列作为函数 length() 的参数。&lt;br /&gt;
这一类的操作特别频繁，特别是在下一节里，当我们需要分组的时候，会讲到这个特别的符号 .N。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;特别的符号 .N 
.N 是一个内建的变量，它表示当前的分组中，对象的数目。在下一节，当它和 by 一起使用的时候，我们会发现它特别有用。还没有涉及到分组的时候，它只是简单地返回行的数目。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以，我们可以用 .N 来完成这个任务：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ans &amp;lt;- flights[origin == &amp;quot;JFK&amp;quot; &amp;amp; month == 6L, .N]
ans
# [1] 8422
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* 再说一遍，首先在i参数里，找到所有符合 origin (机场)是&amp;quot;JFK&amp;quot;，并且 month (月份)是 6 这样条件的行。   
* 在参数j里，我们只指定了 .N，其他什么也没指定。所以实际上我们什么也没做。我们只是返回了符合条件的行的数目（就是行的 length长度）。   
* 注意，我们没有用 list() 或者 .() 包围 .N，所以返回值是个向量。
我们也可以这样完成这个任务 nrow(flights[origin == &amp;quot;JFK&amp;quot; &amp;amp; month == 6L])。但是，这会从整个data.table里面subset符合条件的行，然后用 nrow() 返回行的数目，这是没有必要的，而且效率低下。我们会在 data.table的设计 这个教程里面说明这一点和其他的优化方法。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;g-太棒了-但我应该如何用参数j里面的名字引用列-就像在data-frame那样:3d5b18c834d19c525ed890cfd64b400c&#34;&gt;g) 太棒了！但我应该如何用参数j里面的名字引用列（就像在data.frame那样）&lt;/h4&gt;

&lt;p&gt;你可以使用 with = FALSE 来引用列名。&lt;br /&gt;
－ 用data.frame的方式，选取 arr_delay 和 dep_delay 两列&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ans &amp;lt;- flights[, c(&amp;quot;arr_delay&amp;quot;, &amp;quot;dep_delay&amp;quot;), with=FALSE]
head(ans)
#    arr_delay dep_delay
# 1:        13        14
# 2:        13        -3
# 3:         9         2
# 4:       -26        -8
# 5:         1         2
# 6:         0         4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个参数叫做 with，是根据 R里面的函数 with() 演变而来的。假设你有一个data.frame叫做 DF，想要subset所有符合 x&amp;gt;1 的行。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DF = data.frame(x = c(1,1,1,2,2,3,3,3), y = 1:8)

## (1) normal way
DF[DF$x &amp;gt; 1, ] # data.frame needs that &#39;,&#39; as well
#   x y
# 4 2 4
# 5 2 5
# 6 3 6
# 7 3 7
# 8 3 8

## (2) using with
DF[with(DF, x &amp;gt; 1), ]
#   x y
# 4 2 4
# 5 2 5
# 6 3 6
# 7 3 7
# 8 3 8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* 在上面的 (2) using with里面，使用 with()，我们像变量一样使用DF的x列。
因此，在data.table里，我们设置 with=FALSE，使得我们不能再像变量一样引用列了，这被保存在“data.frame mode”中。
* 我们也可以使用 - 或者 ! 来排除列。比如：
## not run

# returns all columns except arr_delay and dep_delay
ans &amp;lt;- flights[, !c(&amp;quot;arr_delay&amp;quot;, &amp;quot;dep_delay&amp;quot;), with=FALSE]
# or
ans &amp;lt;- flights[, -c(&amp;quot;arr_delay&amp;quot;, &amp;quot;dep_delay&amp;quot;), with=FALSE]

* R语言从V1.9.5版开始，可以指定开始和结束的列名，比如通过指定 year:day 来选择前三列。
## not run

# returns year,month and day
ans &amp;lt;- flights[, year:day, with=FALSE]
# returns day, month and year
ans &amp;lt;- flights[, day:year, with=FALSE]
# returns all columns except year, month and day
ans &amp;lt;- flights[, -(year:day), with=FALSE]
ans &amp;lt;- flights[, !(year:day), with=FALSE]

这在交互式的工作中特别方便。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;with=FALSE 是data.table的默认值，因为我们可以通过参数j表达式，来做更多的事，特别是接下来一节我们要讲到的，和 by 的联合。&lt;/p&gt;

&lt;h2 id=&#34;2-聚合:3d5b18c834d19c525ed890cfd64b400c&#34;&gt;2.聚合&lt;/h2&gt;

&lt;p&gt;在前面一节，我们已经了解了参数i和j，知道了data.table的基本语法。在这一节，我们学习如何跟 by 相结合，做一些分组的操作。先来看看几个例子。&lt;/p&gt;

&lt;h4 id=&#34;a-用by分组:3d5b18c834d19c525ed890cfd64b400c&#34;&gt;a) 用by分组&lt;/h4&gt;

&lt;p&gt;－ 如何获取每个机场起飞的航班数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ans &amp;lt;- flights[, .(.N), by=.(origin)]
ans
#    origin     N
# 1:    JFK 81483
# 2:    LGA 84433
# 3:    EWR 87400

## or equivalently using a character vector in &#39;by&#39;
# ans &amp;lt;- flights[, .(.N), by=&amp;quot;origin&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* 我们知道 .N 表示当前的分组中，对象的数目。先按照 origin 列分组，再用 .N 获取每组的数目。
* 通过 head(flights)，我们可以看到结果里面，机场是按照“JFK”, “LGA” 然后 “EWR” 的顺序排列的。原始数据里，被分组的那一列变量的顺序，也体现在结果里面。   
* 既然我们没有在参数j里面指定列名，那这一列就自然是 N 了。
* by 也接受一个包含列名的字符向量作为参数。这在写代码的时候特别有用，比如设计一个函数，它的参数是要被分组的列。
* 当参数j和by里面只有一列，我们可以省略 .()，这实在很方便。刚刚的任务我们可以这样做：
ans &amp;lt;- flights[, .N, by=origin]
ans
#    origin     N
# 1:    JFK 81483
# 2:    LGA 84433
# 3:    EWR 87400

只要允许，我们就会使用这种方便的形式。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;－ 如何获取美航（carrier code代码是“AA”）在每个机场起飞的航班数
航空公司代码“AA”代表美航。每个航空公司的代码都是唯一的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ans &amp;lt;- flights[carrier == &amp;quot;AA&amp;quot;, .N, by=origin]
ans
#    origin     N
# 1:    JFK 11923
# 2:    LGA 11730
# 3:    EWR  2649
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* 我们首先通过参数i，指定表达式 carrier == &amp;quot;AA&amp;quot;，选取符合条件的行。
* 对于这些行，我们再按 origin 分组，获取每组的数目。再次声明，实际上没有列被重新创建，因为参数j表达式不需要获取列，因此在计算速度和内存使用量这两方面，取得最优的效果。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;－ 如何获取美航在所有机场的起／降的数目&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ans &amp;lt;- flights[carrier == &amp;quot;AA&amp;quot;, .N, by=.(origin,dest)]
head(ans)
#    origin dest    N
# 1:    JFK  LAX 3387
# 2:    LGA  PBI  245
# 3:    EWR  LAX   62
# 4:    JFK  MIA 1876
# 5:    JFK  SEA  298
# 6:    EWR  MIA  848

## or equivalently using a character vector in &#39;by&#39;
# ans &amp;lt;- flights[carrier == &amp;quot;AA&amp;quot;, .N, by=c(&amp;quot;origin&amp;quot;, &amp;quot;dest&amp;quot;)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* 参数by 可以接受多个列。我们可以指定所有我们想分组的列。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;－ 如何获取美航在所有机场的起／降的平均延误时间&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ans &amp;lt;- flights[carrier == &amp;quot;AA&amp;quot;, 
    .(mean(arr_delay), mean(dep_delay)), 
    by=.(origin, dest, month)]
ans
#      origin dest month         V1         V2
#   1:    JFK  LAX     1   6.590361 14.2289157
#   2:    LGA  PBI     1  -7.758621  0.3103448
#   3:    EWR  LAX     1   1.366667  7.5000000
#   4:    JFK  MIA     1  15.720670 18.7430168
#   5:    JFK  SEA     1  14.357143 30.7500000
#  ---                                        
# 196:    LGA  MIA    10  -6.251799 -1.4208633
# 197:    JFK  MIA    10  -1.880184  6.6774194
# 198:    EWR  PHX    10  -3.032258 -4.2903226
# 199:    JFK  MCO    10 -10.048387 -1.6129032
# 200:    JFK  DCA    10  16.483871 15.5161290
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* 我们没有在参数j表达式中指定列名，它们会自动命名为(V1, V2)。    * 再次声明，原数据里面的顺序，会反映在结果中。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可是，如果我们想让结果按照 origin, dest 和 month 排序呢？&lt;/p&gt;

&lt;h4 id=&#34;b-参数keyby:3d5b18c834d19c525ed890cfd64b400c&#34;&gt;b) 参数keyby&lt;/h4&gt;

&lt;p&gt;data.table本身就被设计成能保持原数据的顺序。在一些情况下，必须保持原来的顺序。但是，有时我们希望自动根据分组的变量排序。&lt;/p&gt;

&lt;p&gt;－ 如何按照分组的变量排序&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ans &amp;lt;- flights[carrier == &amp;quot;AA&amp;quot;, 
    .(mean(arr_delay), mean(dep_delay)), 
    keyby=.(origin, dest, month)]
ans
#      origin dest month         V1         V2
#   1:    EWR  DFW     1   6.427673 10.0125786
#   2:    EWR  DFW     2  10.536765 11.3455882
#   3:    EWR  DFW     3  12.865031  8.0797546
#   4:    EWR  DFW     4  17.792683 12.9207317
#   5:    EWR  DFW     5  18.487805 18.6829268
#  ---                                        
# 196:    LGA  PBI     1  -7.758621  0.3103448
# 197:    LGA  PBI     2  -7.865385  2.4038462
# 198:    LGA  PBI     3  -5.754098  3.0327869
# 199:    LGA  PBI     4 -13.966667 -4.7333333
# 200:    LGA  PBI     5 -10.357143 -6.8571429
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* 我们做的，只是把 by 改为了 keyby。这会自动的将结果按照升序排列。注意 keyby() 在完成操作后生效，例如，在计算结果后再排序。   
keys：实际上 keyby 做的不只是排序。它在排序之后，设置一个叫做sorted的属性。我们会在下一教程学习更多关于 keys的内容。   
现在，你需要知道的，就是使用 keyby 自动排序。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;c-chaining表达式:3d5b18c834d19c525ed890cfd64b400c&#34;&gt;c) chaining表达式&lt;/h4&gt;

&lt;p&gt;让我们再来考虑下“获取美航在所有机场的起／降的数目”的问题。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ans &amp;lt;- flights[carrier == &amp;quot;AA&amp;quot;, .N, by = .(origin, dest)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;－ 如何让 ans 按origin的升序、按dest的降序排列
我们可以将中间结果保存为一个临时变量，再对这个变量使用 order(origin, -dest) 排序。这看上去还挺简洁明了的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ans &amp;lt;- ans[order(origin, -dest)]
head(ans)
#    origin dest    N
# 1:    EWR  PHX  121
# 2:    EWR  MIA  848
# 3:    EWR  LAX   62
# 4:    EWR  DFW 1618
# 5:    JFK  STT  229
# 6:    JFK  SJU  690
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* 回忆一下，我们在函数 order()中，对一个字符型的列使用 &amp;quot;-&amp;quot; 来降序排列。由于data.table的内部查询优化(internal query optimisation)，这样做是可行的。
* 再回忆一下 order(...)已经通过data.table内部的快速基数排序函数 forder()优化过了。那么，我们可以继续使用熟悉的R的基础函数，而不是考虑使用data.table提供的速度快内存消耗少的排序方法。我们会在data.table internals的教程中说明更多细节。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是这么做会生成一个临时变量，然后再修改这个临时变量。其实我们可以通过添加chaining表达式，避免生成临时变量。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ans &amp;lt;- flights[carrier == &amp;quot;AA&amp;quot;, .N, by=.(origin, dest)][order(origin, -dest)]
head(ans, 10)
#     origin dest    N
#  1:    EWR  PHX  121
#  2:    EWR  MIA  848
#  3:    EWR  LAX   62
#  4:    EWR  DFW 1618
#  5:    JFK  STT  229
#  6:    JFK  SJU  690
#  7:    JFK  SFO 1312
#  8:    JFK  SEA  298
#  9:    JFK  SAN  299
# 10:    JFK  ORD  432
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* 我们可以一个接一个地添加表达式，做一系列操作，就像这样：DT[...][...][...]。
* 或者你可以换行写：
DT[...
 ][...
 ][...
 ]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;d-by表达式:3d5b18c834d19c525ed890cfd64b400c&#34;&gt;d) by表达式&lt;/h4&gt;

&lt;p&gt;－ 参数by也可以接受表达式吗？还是只能指定列&lt;br /&gt;
当然可以接受表达式。举个例子，如果我们想要知道，有多少航班起飞延误但却提前／准时到达的，有多少航班起飞和到达都延误了……&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ans &amp;lt;- flights[, .N, .(dep_delay&amp;gt;0, arr_delay&amp;gt;0)]
ans
#    dep_delay arr_delay      N
# 1:      TRUE      TRUE  72836
# 2:     FALSE      TRUE  34583
# 3:     FALSE     FALSE 119304
# 4:      TRUE     FALSE  26593
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* 最后一行，满足 dep_delay &amp;gt; 0 = TRUE 且 arr_delay &amp;gt; 0 = FALSE 的条件。我们知道有26593次航班起飞延误但却提前／准时到达了。
* 注意，我们没有在by表达式里面指定任何列名。然而结果里面，列名还是自动的生成了。
* 我们可以在表达式里面指定其他的列，比如：DT[, .N, by=.(a, b&amp;gt;0)]。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;e-在参数j里面指定多个列:3d5b18c834d19c525ed890cfd64b400c&#34;&gt;e) 在参数j里面指定多个列&lt;/h4&gt;

&lt;p&gt;－ 必须分别对每列指定 mean() 函数吗
当然不必分别对每列输入 mean(myCol) 了。要是我们有100列要计算平均值，不就惨了吗。&lt;br /&gt;
如何高效地计算呢。记不记得这个小贴士-“只要参数j 返回一个list，这个list的每一个元素都会被转换成结果data.table的一列。”假设我们分组的时候，可以像变量一样，引用每个分组的数据，那么就可以循环对所有的列应用函数 lapply() ，而不需要学习新的函数。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;特殊的语法 .SD:
data.table提供一个特殊的语法，形式是 .SD。它是 Subset of Data 的缩写。它自身就是一个data.table，包含通过by 分组后的每一组。
回忆一下，一个data.table本质上是一个list，它们的列包含的元素个数都相同（其实就是行数）。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;让我们用之前的一个data.table DT来看看 .SD 是如何使用的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DT
#    ID a  b  c
# 1:  b 1  7 13
# 2:  b 2  8 14
# 3:  b 3  9 15
# 4:  a 4 10 16
# 5:  a 5 11 17
# 6:  c 6 12 18

DT[, print(.SD), by=ID]
#    a b  c
# 1: 1 7 13
# 2: 2 8 14
# 3: 3 9 15
#    a  b  c
# 1: 4 10 16
# 2: 5 11 17
#    a  b  c
# 1: 6 12 18
# Empty data.table (0 rows) of 1 col: ID
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* .SD 包含除了分组依据的那一列以外的所有列。
* 返回值依旧保持了原数据的顺序。首先打印出来的是 ID=“b” 的数据，然后是 ID=“a” 的，最后是  ID=“c” 的。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了对复数的列进行计算，我们可以简单地使用函数 lapply()。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DT[, lapply(.SD, mean), by=ID]
#    ID   a    b    c
# 1:  b 2.0  8.0 14.0
# 2:  a 4.5 10.5 16.5
# 3:  c 6.0 12.0 18.0 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* .SD 分别包含了ID是 a、b、c的所有行，它们分别对应了各自的组。我们应用函数 lapply() 对每列计算平均值。
* 每一组返回包含三个平均数的list，这些构成了最终返回的data.table。
* 既然函数 lapply() 返回 list，我们就不需要在外面多加 .() 了。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;差不多可以了，再补充一点。在 flights 这个 data.table里面，我们执行计算 arr_delay 和 dep_delay 这两列的平均值。但是，.SD 默认包含用于分组的所有列的平均值。&lt;/p&gt;

&lt;p&gt;－如何指定希望计算平均值的列&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.SDcols
使用参数 .SDcols。它接受列名或者列索引。比如，.SDcols = c(&amp;quot;arr_delay&amp;quot;, &amp;quot;dep_delay&amp;quot;)能确保.SD之包含 arr_delay 和 dep_delay 这两列。
和 with = FALSE 一样，我们也可以使用 - 或者 ! 来移除列。比如，我们指定 !(colA:colB) 或者 -(colA:colB)表示移除从 colA 到 colB 的所有列。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在让我们试着用 .SD 和 .SDcols 来获取 arr_delay 和 dep_delay 这两列的平均值，并且按照 origin, dest 和 month 来分组。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flights[carrier == &amp;quot;AA&amp;quot;,                     ## Only on trips with carrier &amp;quot;AA&amp;quot;
        lapply(.SD, mean),                   ## compute the mean
        by=.(origin, dest, month),           ## for every &#39;origin,dest,month&#39;
        .SDcols=c(&amp;quot;arr_delay&amp;quot;, &amp;quot;dep_delay&amp;quot;)] ## for just those specified in .SDcols
#      origin dest month  arr_delay  dep_delay
#   1:    JFK  LAX     1   6.590361 14.2289157
#   2:    LGA  PBI     1  -7.758621  0.3103448
#   3:    EWR  LAX     1   1.366667  7.5000000
#   4:    JFK  MIA     1  15.720670 18.7430168
#   5:    JFK  SEA     1  14.357143 30.7500000
#  ---                                        
# 196:    LGA  MIA    10  -6.251799 -1.4208633
# 197:    JFK  MIA    10  -1.880184  6.6774194
# 198:    EWR  PHX    10  -3.032258 -4.2903226
# 199:    JFK  MCO    10 -10.048387 -1.6129032
# 200:    JFK  DCA    10  16.483871 15.5161290
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;f-对每组subset-sd:3d5b18c834d19c525ed890cfd64b400c&#34;&gt;f) 对每组subset .SD&lt;/h4&gt;

&lt;p&gt;－ 如何返回每个月的前两行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ans &amp;lt;- flights[, head(.SD, 2), by=month]
head(ans)
#    month year day dep_time dep_delay arr_time arr_delay cancelled carrier tailnum flight origin
# 1:     1 2014   1      914        14     1238        13         0      AA  N338AA      1    JFK
# 2:     1 2014   1     1157        -3     1523        13         0      AA  N335AA      3    JFK
# 3:     2 2014   1      859        -1     1226         1         0      AA  N783AA      1    JFK
# 4:     2 2014   1     1155        -5     1528         3         0      AA  N784AA      3    JFK
# 5:     3 2014   1      849       -11     1306        36         0      AA  N784AA      1    JFK
# 6:     3 2014   1     1157        -3     1529        14         0      AA  N787AA      3    JFK
#    dest air_time distance hour min
# 1:  LAX      359     2475    9  14
# 2:  LAX      363     2475   11  57
# 3:  LAX      358     2475    8  59
# 4:  LAX      358     2475   11  55
# 5:  LAX      375     2475    8  49
# 6:  LAX      368     2475   11  57
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* .SD 包含了每组的所有行。我们可以简单的subset各组数据的前两行。
* 对每组数据，head(.SD, 2)返回的data.table同时也是个list。所以不需要用 .() 包围起来。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;g-为什么参数j这么灵活:3d5b18c834d19c525ed890cfd64b400c&#34;&gt;g) 为什么参数j这么灵活&lt;/h4&gt;

&lt;p&gt;这样，我们有了符合R语言风格的语法，我们也使用R语言里面既存的函数定义，而不是定义新的函数。我们用教程一开始创建的DT来说明。&lt;/p&gt;

&lt;p&gt;－如何保存按照ID分组后数据中的 a列和 b列 的信息&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DT
#    ID a  b  c
# 1:  b 1  7 13
# 2:  b 2  8 14
# 3:  b 3  9 15
# 4:  a 4 10 16
# 5:  a 5 11 17
# 6:  c 6 12 18

DT[, .(val = c(a,b)), by=ID]
#     ID val
#  1:  b   1
#  2:  b   2
#  3:  b   3
#  4:  b   7
#  5:  b   8
#  6:  b   9
#  7:  a   4
#  8:  a   5
#  9:  a  10
# 10:  a  11
# 11:  c   6
# 12:  c  12
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* 就这样，不需要特殊的语法。我们需要知道的，就是用函数 c() 指定需要连结的向量。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;－ 如何将刚刚的数据，作为一列返回&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DT[, .(val = list(c(a,b))), by=ID]
#    ID         val
# 1:  b 1,2,3,7,8,9
# 2:  a  4, 5,10,11
# 3:  c        6,12
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* 我们首先用 c(a,b) 连结了每组的值，然后用 list() 包围起来。那么对于每组数据，我们返回一个所有连结后的值的 list。
* 注意，那些逗号都是用来辅助显示的。一个list中的元素可以包含任何对象。在这个例子里，每个元素是一个向量，它们的长度都不相同。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一旦你对参数j的用法产生了兴趣，你会发现语法是多么强大。理解这些的一个有效的方法就是，在 print() 的帮助下，多多使用。&lt;br /&gt;
例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;## (1) look at the difference between
DT[, print(c(a,b)), by=ID]
# [1] 1 2 3 7 8 9
# [1]  4  5 10 11
# [1]  6 12
# Empty data.table (0 rows) of 1 col: ID

## (2) and
DT[, print(list(c(a,b))), by=ID]
# [[1]]
# [1] 1 2 3 7 8 9
# 
# [[1]]
# [1]  4  5 10 11
# 
# [[1]]
# [1]  6 12
# Empty data.table (0 rows) of 1 col: ID
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在(1)里面，每组返回一个向量，它们的长度分别是6，4，2.但是(2)里面，每组返回一个长度都为1的list，它们的第一个元素包含了长度为6，4，2的向量。因此，(1)的结果的长度是6+4+2=12，(2)的结果的长度是1+1+1=3。&lt;/p&gt;

&lt;h2 id=&#34;总结:3d5b18c834d19c525ed890cfd64b400c&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;data.table的语法形式是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DT[i, j, by]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;指定参数i：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* 类似于data.frame，我们可以subset行，除非不需要重复地使用 DT$，既然我们能将列当做变量来引用。 
* 我们可以使用order()排序。为了得到更快速的效果，order()函数内部使用了data.table的快速排序。 
我们可以通过参数i做更多的事，得到更快速的选取和连结。我们可以在教程“Keys and fast binary search based subsets”和“Joins and rolling joins”中学到这些。 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;指定参数j：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* 以data.table的形式选取列：DT[, .(colA, colB)]。
* 以data.frame的形式选取列：DT[, c(&amp;quot;colA&amp;quot;, &amp;quot;colB&amp;quot;), with=FALSE]。
* 按列进行计算：DT[, .(sum(colA), mean(colB))]。
* 如果需要：DT[, .(sA =sum(colA), mB = mean(colB))]。
* 和i共同使用：DT[colA &amp;gt; value, sum(colB)]。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;指定参数by：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* 通过by，我们可以指定列，或者列名，甚至表达式，进行分组。参数j可以很灵活地配置参数i和by实现强大的功能。
* by可以指定多个列，也可以指定表达式。
* 我们可以用 keyby，对分组的结果自动排序。
* 我们可以在参数j中指定 .SD 和 .SDcols，对复数的列进行操作。例如：   
  1.把函数fun 应用到所有 .SDcols指定的列上，同时对参数by指定的列进行分组：DT[, lapply(.SD, fun), by=., .SDcols=...]。 
  2.返回每组册前两行：DT[, head(.SD, 2), by=.]。
  3.三个参数联合使用：DT[col &amp;gt; val, head(.SD, 1), by=.]。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;小提示：&lt;br /&gt;
只要j返回一个list，这个list的每个元素都会是结果data.table的一列。&lt;/p&gt;

&lt;p&gt;下一讲，我们学习如何用reference来add／update／delete某一列，如何通过i和by合并它们。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>