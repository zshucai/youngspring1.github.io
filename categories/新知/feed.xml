<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>新知 on 行行重行行</title>
    <link>http://youngspring1.github.io/categories/%E6%96%B0%E7%9F%A5/</link>
    <description>Recent content in 新知 on 行行重行行</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>Copyright (c) 2016. All rights reserved.</copyright>
    <lastBuildDate>Sun, 13 Mar 2016 18:57:40 +0800</lastBuildDate>
    <atom:link href="http://youngspring1.github.io/categories/%E6%96%B0%E7%9F%A5/feed/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>data.table 讲义1（翻译中）</title>
      <link>http://youngspring1.github.io/post/2016-03-13-datatable1/</link>
      <pubDate>Sun, 13 Mar 2016 18:57:40 +0800</pubDate>
      
      <guid>http://youngspring1.github.io/post/2016-03-13-datatable1/</guid>
      <description>

&lt;p&gt;最近使用data.table这个library计算数据的聚合信息，比sql语句简单明了不是一点半点，于是想把data.table的资料翻译出来。&lt;/p&gt;

&lt;p&gt;目录：&lt;br /&gt;
1) data.table 介绍&lt;br /&gt;
2) Reference semantics&lt;br /&gt;
3) Keys and fast binary search based subsets&lt;br /&gt;
4) Efficient reshaping using data.tables&lt;/p&gt;

&lt;p&gt;原文地址：&lt;br /&gt;
1) &lt;a href=&#34;https://rawgit.com/wiki/Rdatatable/data.table/vignettes/datatable-intro-vignette.html&#34;&gt;Introduction to data.table&lt;/a&gt;&lt;br /&gt;
2) &lt;a href=&#34;https://rawgit.com/wiki/Rdatatable/data.table/vignettes/datatable-reference-semantics.html&#34;&gt;Reference semantics&lt;/a&gt;&lt;br /&gt;
3) &lt;a href=&#34;https://rawgit.com/wiki/Rdatatable/data.table/vignettes/datatable-keys-fast-subset.html&#34;&gt;Keys and fast binary search based subsets&lt;/a&gt;&lt;br /&gt;
4) &lt;a href=&#34;https://rawgit.com/wiki/Rdatatable/data.table/vignettes/datatable-reshape.html&#34;&gt;Efficient reshaping using data.tables&lt;/a&gt;&lt;br /&gt;
5) &lt;a href=&#34;https://rawgit.com/wiki/Rdatatable/data.table/vignettes/datatable-faq.html&#34;&gt;Frequently asked questions&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;本讲义介绍data.table的语法，大概的形式，如何subset行，如何按列select／compute，如何分组聚合。熟悉data.frame的数据结构是有帮助的，不过不熟悉也没关系。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;使用data-table分析数据:3d5b18c834d19c525ed890cfd64b400c&#34;&gt;使用data.table分析数据&lt;/h2&gt;

&lt;p&gt;支持操作数据的功能，例如subset、group、update、join等。&lt;br /&gt;
这些功能可以让我们：&lt;br /&gt;
*
*
*
简要的讲，如果你对减小计算复杂度和计算时间有着迫切的需求，那么这个package就是为你量身打造的。data.table就是干这事儿的。我们通过这一系列讲义，说明这些功能。&lt;/p&gt;

&lt;h2 id=&#34;数据:3d5b18c834d19c525ed890cfd64b400c&#34;&gt;数据&lt;/h2&gt;

&lt;p&gt;在这个讲义中，我们使用&lt;a href=&#34;https://github.com/arunsrinivasan/flights/wiki/NYC-Flights-2014-data&#34;&gt;NYC-flights14&lt;/a&gt;的数据。它包含了2014年纽约机场发出的所有航班信息。这份数据只有2014年1月到10月是公开的。&lt;br /&gt;
我们可以使用data.table的fread()函数，用下面的方式，快速直接读取航班数据：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flights &amp;lt;- fread(&amp;quot;https://raw.githubusercontent.com/wiki/arunsrinivasan/    flights/NYCflights14/flights14.csv&amp;quot;)
flights
#         year month day dep_time dep_delay arr_time arr_delay cancelled carrier tailnum flight
#      1: 2014     1   1      914        14     1238        13         0      AA  N338AA      1
#      2: 2014     1   1     1157        -3     1523        13         0      AA  N335AA      3
#      3: 2014     1   1     1902         2     2224         9         0      AA  N327AA     21
#      4: 2014     1   1      722        -8     1014       -26         0      AA  N3EHAA     29
#      5: 2014     1   1     1347         2     1706         1         0      AA  N319AA    117
#     ---                                                                                      
# 253312: 2014    10  31     1459         1     1747       -30         0      UA  N23708   1744
# 253313: 2014    10  31      854        -5     1147       -14         0      UA  N33132   1758
# 253314: 2014    10  31     1102        -8     1311        16         0      MQ  N827MQ   3591
# 253315: 2014    10  31     1106        -4     1325        15         0      MQ  N511MQ   3592
# 253316: 2014    10  31      824        -5     1045         1         0      MQ  N813MQ   3599
#         origin dest air_time distance hour min
#      1:    JFK  LAX      359     2475    9  14
#      2:    JFK  LAX      363     2475   11  57
#      3:    JFK  LAX      351     2475   19   2
#      4:    LGA  PBI      157     1035    7  22
#      5:    JFK  LAX      350     2475   13  47
#     ---                                       
# 253312:    LGA  IAH      201     1416   14  59
# 253313:    EWR  IAH      189     1400    8  54
# 253314:    LGA  RDU       83      431   11   2
# 253315:    LGA  DTW       75      502   11   6
# 253316:    LGA  SDF      110      659    8  24
dim(flights)
# [1] 253316     17
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;既然整个讲义我们都会使用这份数据，那你不妨先下载到你的电脑上，然后每次使用的时候再读取。&lt;/p&gt;

&lt;h2 id=&#34;介绍:3d5b18c834d19c525ed890cfd64b400c&#34;&gt;介绍&lt;/h2&gt;

&lt;p&gt;在本章中，我们会学习下面两点：&lt;br /&gt;
1. 基础 － 什么是data.table，它的形式，如何subset行，如何select列，如何按列进行运算。&lt;br /&gt;
2. 聚合 － 按组聚合的效果。&lt;/p&gt;

&lt;h2 id=&#34;1-基础:3d5b18c834d19c525ed890cfd64b400c&#34;&gt;1.基础&lt;/h2&gt;

&lt;h4 id=&#34;a-什么是data-table:3d5b18c834d19c525ed890cfd64b400c&#34;&gt;a)什么是data.table&lt;/h4&gt;

&lt;p&gt;data.table是R语言的一个包，它是对data.frames的增强。在上文（读取航班）“数据”的部分，我们通过函数fread()创建了一个data.table。我们也可以通过函数data.table()创建一个data.table，比如这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DT = data.table(ID = c(&amp;quot;b&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;c&amp;quot;), a = 1:6, b = 7:12, c=13:18)
DT
#    ID a  b  c
# 1:  b 1  7 13
# 2:  b 2  8 14
# 3:  b 3  9 15
# 4:  a 4 10 16
# 5:  a 5 11 17
# 6:  c 6 12 18
class(DT$ID)
# [1] &amp;quot;character&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们也可以通过as.data.table()将已经存在的对象转化成data.table。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;注意：
* 不同于data.frames，字符型的列，不会被自动转化成因子。
* 行号后面有个冒号，用于隔开第一列的内容。
* 如果数据的条目超过了全局选项datatable.print.nrows所定义的数值（默认是100条），那么只会输出数据最开头和最末尾的5行。就如同上文（读取航班）“数据”的部分。

getOption(&amp;quot;datatable.print.nrows&amp;quot;)
# [1] 100

* data.table不能设置行的名称。我们会在第三讲中说明原因。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;b-形式-data-table增强了什么:3d5b18c834d19c525ed890cfd64b400c&#34;&gt;b)形式－data.table增强了什么&lt;/h4&gt;

&lt;p&gt;和data.frame相反，我们能做的可不仅仅局限于subset行或者select列。首先介绍下data.table的语法，如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DT[i, j, by]

##   R:      i                 j        by
## SQL:  where   select | update  group by
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你有SQL语句的基础，那么你应该能马上明白data.table的语法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;语法是：
对于DT这个data.table，使用 i 来subset行，然后计算 j ，最后用 by 分组。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;c-subset行:3d5b18c834d19c525ed890cfd64b400c&#34;&gt;c)subset行&lt;/h4&gt;

&lt;p&gt;－ 获取六月份所有从&amp;rdquo;JFK&amp;rdquo;机场起飞的航班&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ans &amp;lt;- flights[origin == &amp;quot;JFK&amp;quot; &amp;amp; month == 6L]
head(ans)
#    year month day dep_time dep_delay arr_time arr_delay cancelled carrier tailnum flight origin
# 1: 2014     6   1      851        -9     1205        -5         0      AA  N787AA      1    JFK
# 2: 2014     6   1     1220       -10     1522       -13         0      AA  N795AA      3    JFK
# 3: 2014     6   1      718        18     1014        -1         0      AA  N784AA      9    JFK
# 4: 2014     6   1     1024        -6     1314       -16         0      AA  N791AA     19    JFK
# 5: 2014     6   1     1841        -4     2125       -45         0      AA  N790AA     21    JFK
# 6: 2014     6   1     1454        -6     1757       -23         0      AA  N785AA    117    JFK
#    dest air_time distance hour min
# 1:  LAX      324     2475    8  51
# 2:  LAX      329     2475   12  20
# 3:  LAX      326     2475    7  18
# 4:  LAX      320     2475   10  24
# 5:  LAX      326     2475   18  41
# 6:  LAX      329     2475   14  54
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* 通过data.frame的frame？，列可以像变量一样被引用。因此，我们不需要加上 flights$ 前缀，比如 flights$dest 和 flights$month，而是直接简单地引用 dest 和 month这两列。
* 满足 origin == &amp;quot;JFK&amp;quot; &amp;amp; month == 6L 这两个条件的行会被抽出出来。既然我们没有指定其他的条件，一个包含原数据里面所有列的data.table会被返回。
* 语法里面[i,j,k]的逗号不是必须的，当然如果指定了逗号，比如 flights[dest == &amp;quot;JFK&amp;quot; &amp;amp; month == 6L, ] 也是没问题的。但在data.frame里面，逗号却是必须的。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;－ 获取 flights 开头的两行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ans &amp;lt;- flights[1:2]
ans
#    year month day dep_time dep_delay arr_time arr_delay cancelled carrier tailnum flight origin
# 1: 2014     1   1      914        14     1238        13         0      AA  N338AA      1    JFK
# 2: 2014     1   1     1157        -3     1523        13         0      AA  N335AA      3    JFK
#    dest air_time distance hour min
# 1:  LAX      359     2475    9  14
# 2:  LAX      363     2475   11  57
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* 我们没有指定任何条件。行的索引已经自动提供给参数 i 了。因此，我们得到一个包含原数据 flight 里所有列的data.table（for 这些行的索引？）。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;－ 排序（先按 origin列 的升序，再按 dest 的降序排列）
我们可以通过R语言的基础函数 order() 来完成这个功能。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ans &amp;lt;- flights[order(origin, -dest)]
head(ans)
#    year month day dep_time dep_delay arr_time arr_delay cancelled carrier tailnum flight origin
# 1: 2014     1   5      836         6     1151        49         0      EV  N12175   4419    EWR
# 2: 2014     1   6      833         7     1111        13         0      EV  N24128   4419    EWR
# 3: 2014     1   7      811        -6     1035       -13         0      EV  N12142   4419    EWR
# 4: 2014     1   8      810        -7     1036       -12         0      EV  N11193   4419    EWR
# 5: 2014     1   9      833        16     1055         7         0      EV  N14198   4419    EWR
# 6: 2014     1  13      923        66     1154        66         0      EV  N12157   4419    EWR
#    dest air_time distance hour min
# 1:  XNA      195     1131    8  36
# 2:  XNA      190     1131    8  33
# 3:  XNA      179     1131    8  11
# 4:  XNA      184     1131    8  10
# 5:  XNA      181     1131    8  33
# 6:  XNA      188     1131    9  23
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;内置的 order() 函数
* 我们可以对一个字符型的列，使用减号“-”，来实现降序排列。
* 另外，函数 order() 其实调用了data.table的快速基数排序函数 forder()，它比 base::order 快很多。这是一个说明它们基本区别的例子：

odt = data.table(col=sample(1e7))
(t1 &amp;lt;- system.time(ans1 &amp;lt;- odt[base::order(col)]))  ## uses order from base R
#    user  system elapsed 
#   8.610   0.056   8.708
(t2 &amp;lt;- system.time(ans2 &amp;lt;- odt[order(col)]))        ## uses data.table&#39;s forder
#    user  system elapsed 
#   0.526   0.024   0.553
(identical(ans1, ans2))
# [1] TRUE

order() 比 base::order 大约快了16倍。我们会在data.table的内部讲义中讨论data.table快速排序的更多细节。
* 因此，使用我们熟悉的函数，就可以显著地提高分析效率。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;d-select列:3d5b18c834d19c525ed890cfd64b400c&#34;&gt;d)select列&lt;/h4&gt;

&lt;h4 id=&#34;f-j:3d5b18c834d19c525ed890cfd64b400c&#34;&gt;f)j&lt;/h4&gt;

&lt;h4 id=&#34;g-names:3d5b18c834d19c525ed890cfd64b400c&#34;&gt;g)names&lt;/h4&gt;

&lt;h2 id=&#34;2-聚合:3d5b18c834d19c525ed890cfd64b400c&#34;&gt;2.聚合&lt;/h2&gt;

&lt;h4 id=&#34;a-分组:3d5b18c834d19c525ed890cfd64b400c&#34;&gt;a)分组&lt;/h4&gt;

&lt;h4 id=&#34;b-keyby:3d5b18c834d19c525ed890cfd64b400c&#34;&gt;b)keyby&lt;/h4&gt;

&lt;h4 id=&#34;c-chaining:3d5b18c834d19c525ed890cfd64b400c&#34;&gt;c)chaining&lt;/h4&gt;

&lt;h4 id=&#34;d-by表达式:3d5b18c834d19c525ed890cfd64b400c&#34;&gt;d)by表达式&lt;/h4&gt;

&lt;h4 id=&#34;e-j:3d5b18c834d19c525ed890cfd64b400c&#34;&gt;e)j&lt;/h4&gt;

&lt;h4 id=&#34;f-subset:3d5b18c834d19c525ed890cfd64b400c&#34;&gt;f)subset&lt;/h4&gt;

&lt;h4 id=&#34;g-j:3d5b18c834d19c525ed890cfd64b400c&#34;&gt;g)j&lt;/h4&gt;

&lt;h2 id=&#34;总结:3d5b18c834d19c525ed890cfd64b400c&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;data.table的语法形式是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DT[i, j, by]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在我们知道：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;指定i：   
* 类似于data.frame，我们可以subset行，除非
* 我们可以使用order()排序。为了得到更快速的效果，order()函数内部使用了data.table的快速排序。   



指定j：
* 
*
*
*
*

指定by：
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;小提示：&lt;br /&gt;
只要j返回一个list，这个list的每个元素都会是结果data.table的一列。&lt;/p&gt;

&lt;p&gt;下一讲，我们学习如何用reference来add／update／delete某一列，如何通过i和by合并它们。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>R语言中的class()、mode()和typeof()的区别</title>
      <link>http://youngspring1.github.io/post/2016-03-08-r-class/</link>
      <pubDate>Tue, 08 Mar 2016 22:52:12 +0800</pubDate>
      
      <guid>http://youngspring1.github.io/post/2016-03-08-r-class/</guid>
      <description>

&lt;p&gt;今天对R语言中的这三个函数产生了疑惑，为什么有时候它们的运行结果一样，有时候却又不一样？&lt;/p&gt;

&lt;h3 id=&#34;定义:4392bb40a36ba9fbdbf9a9669f2b4fbf&#34;&gt;定义&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;mode&lt;/strong&gt;&lt;br /&gt;
&amp;emsp;The (Storage) Mode of an Object&lt;br /&gt;
&lt;strong&gt;Description&lt;/strong&gt;&lt;br /&gt;
&amp;emsp;Get or set the type or storage mode of an object.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;typeof&lt;/strong&gt;&lt;br /&gt;
&amp;emsp;The Type of an Object&lt;br /&gt;
&lt;strong&gt;Description&lt;/strong&gt;&lt;br /&gt;
&amp;emsp;typeof determines the (R internal) type or storage mode of any object&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;class&lt;/strong&gt;&lt;br /&gt;
&amp;emsp;Object Classes&lt;br /&gt;
&lt;strong&gt;Description&lt;/strong&gt;&lt;br /&gt;
&amp;emsp;R possesses a simple generic function mechanism which can be used for an object-oriented style of programming.&lt;br /&gt;
&amp;emsp;Method dispatch takes place based on the class of the first argument to the generic function.&lt;/p&gt;

&lt;h3 id=&#34;解释:4392bb40a36ba9fbdbf9a9669f2b4fbf&#34;&gt;解释&lt;/h3&gt;

&lt;p&gt;在R里面，每一个对象都有一个mode和一个class。&lt;br /&gt;
前者表示对象在内存中是如何存储的。 (numeric, character, list and function)&lt;br /&gt;
后者表示对象的抽象类型。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;d &amp;lt;- data.frame(V1=c(1,2))
class(d)
# [1] &amp;quot;data.frame&amp;quot;
mode(d)
# [1] &amp;quot;list&amp;quot;
typeof(d)
# list

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过上面的例子，我们可以知道，data frame这种类型，在内存中作为list被存储，但是它们被包装成data frame。&lt;br /&gt;
对于某个函数的参数，它的类型是data frame，却不能说是list。&lt;/p&gt;

&lt;p&gt;再来看mode和typeof。&lt;br /&gt;
mode和typeof通常返回同样的值，但也有例外。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typeof(c(1,2))
# [1] &amp;quot;double&amp;quot;
mode(c(1,2))
# [1] &amp;quot;numeric&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;历史原因啦。R语言由S语言发展而来。&lt;br /&gt;
mode，为了和S语言兼容，返回R的对象的模式。&lt;br /&gt;
typeof是R语言特有的，返回一个R的对象的类型。（哎呀，解释不清楚啦）&lt;/p&gt;

&lt;h3 id=&#34;参考:4392bb40a36ba9fbdbf9a9669f2b4fbf&#34;&gt;参考&lt;/h3&gt;

&lt;p&gt;1.&lt;a href=&#34;http://stackoverflow.com/questions/6258004/r-types-and-classes-of-variables&#34;&gt;http://stackoverflow.com/questions/6258004/r-types-and-classes-of-variables&lt;/a&gt;&lt;br /&gt;
2.&lt;a href=&#34;http://stats.stackexchange.com/questions/3212/mode-class-and-type-of-r-objects&#34;&gt;http://stats.stackexchange.com/questions/3212/mode-class-and-type-of-r-objects&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Git常用命令备忘</title>
      <link>http://youngspring1.github.io/post/2016-03-06-git/</link>
      <pubDate>Sun, 06 Mar 2016 13:53:07 +0800</pubDate>
      
      <guid>http://youngspring1.github.io/post/2016-03-06-git/</guid>
      <description>

&lt;p&gt;不用git简直就是反人类啊。&lt;br /&gt;
不过没有能力一下子把所有的命令都记住，先把常用的几个列下，具体的后面用到了再查。&lt;/p&gt;

&lt;h2 id=&#34;示意图:d71c3921adf591fdd23ac81ec6f69f8c&#34;&gt;示意图&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;http://7xrjai.com1.z0.glb.clouddn.com/20160306-git-map.png&#34; alt=&#34;git-map&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;remote&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;repository&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;index&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;workspace&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;-图中的remote是远程仓库，而repository、index和workspace都是在你本地。&lt;br /&gt;
remote还可以分为trunk repository和your own github repository。
如果你觉得别人的工程很好，想在此基础上嫁接自己的开发，那么fork一下，就会到你自己的github工程列表中。这些remote都是有独立的地址的，比如git自己的代码，提供一个唯一的地址供大家fork：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;https://github.com/git/git.git   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;-图中的repository是本地仓库，如果这个本地仓库刚刚被初始化，还是空的，那么我们需要clone一下远程仓库。&lt;br /&gt;
如果这个本地仓库是以前就创建好的，我们开发代码之前，应该取得（fetch）远程仓库remote的更新。&lt;/p&gt;

&lt;p&gt;-图中的workspace是工作区，就是具体的代码文件。
-图中的index是暂存区，代码某个版本开发好后，需要add进index，就是告诉仓库，我修改了哪些文件，将会提交哪些文件。&lt;br /&gt;
此时使用commit命令来提交文件。&lt;br /&gt;
最后，把修改从本地仓库repository推送（push）到远程仓库（remote）。&lt;/p&gt;

&lt;h2 id=&#34;1-git-clone:d71c3921adf591fdd23ac81ec6f69f8c&#34;&gt;1.git clone&lt;/h2&gt;

&lt;p&gt;重要的事情在前面说，chone之前需要init！&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd proj-dir
$ git init
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;clone命令会在本地主机生成一个目录，与远程主机的版本库同名。&lt;br /&gt;
如果要指定不同的目录名，可以将目录名作为git clone命令的第二个参数。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone &amp;lt;版本库的网址&amp;gt;
$ git clone &amp;lt;版本库的网址&amp;gt; &amp;lt;本地目录名&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;比如，克隆jQuery的版本库。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone https://github.com/jquery/jquery.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;clone支持HTTP(s)、SSH、Git、FTP等协议。&lt;/p&gt;

&lt;h2 id=&#34;2-git-remote:d71c3921adf591fdd23ac81ec6f69f8c&#34;&gt;2.git remote&lt;/h2&gt;

&lt;p&gt;git remote命令列出所有远程主机。&lt;br /&gt;
克隆版本库的时候，所使用的远程主机自动被Git命名为origin。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git remote
origin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用-v选项，可以参看远程主机的网址。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git remote -v
origin  git@github.com:jquery/jquery.git (fetch)
origin  git@github.com:jquery/jquery.git (push)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果想用其他的主机名，需要用git clone命令的-o选项指定。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone -o jQuery https://github.com/jquery/jquery.git
$ git remote
jQuery
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3-git-fetch:d71c3921adf591fdd23ac81ec6f69f8c&#34;&gt;3.git fetch&lt;/h2&gt;

&lt;p&gt;如果远程仓库的代码有更新，我们需要将这些更新取到本地。&lt;br /&gt;
通常建议在修改本地代码前做这件事。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git fetch &amp;lt;远程主机名&amp;gt;
$ git fetch &amp;lt;远程主机名&amp;gt; &amp;lt;分支名&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果不指定分支名，则取回所有分支的更新。&lt;br /&gt;
如果指定分支名，则仅取回指定分支的更新。&lt;/p&gt;

&lt;p&gt;那么，我怎么知道取哪个分支？&lt;br /&gt;
git branch命令的-r选项，可以用来查看远程分支，-a选项查看所有分支。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git branch -r
origin/master

$ git branch -a
* master
remotes/origin/master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的命令表示，本地主机的当前分支是master，远程分支是origin/master。&lt;/p&gt;

&lt;p&gt;fetch只能从远程仓库取得代码，还没有合并到本地的代码中去。需要使用git merge命令或者git rebase命令，在本地分支上合并远程分支。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git merge origin/master
# 或者
$ git rebase origin/master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可是可是，如果我不想合并到现在的分支上怎么办呢。可以使用git checkout命令创建一个新的分支。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git checkout -b newBrach origin/master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面命令表示，在origin/master的基础上，创建一个新分支。&lt;/p&gt;

&lt;h2 id=&#34;4-git-pull:d71c3921adf591fdd23ac81ec6f69f8c&#34;&gt;4.git pull&lt;/h2&gt;

&lt;p&gt;取回远程主机某个分支的更新，并且与本地的指定分支合并。
同最开始的图上看，是不是相当于fetch＋checkout？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git pull &amp;lt;远程主机名&amp;gt; &amp;lt;远程分支名&amp;gt;:&amp;lt;本地分支名&amp;gt;
$ git pull origin next:master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;表示取回origin主机的next分支，与本地的master分支合并。&lt;br /&gt;
如果远程分支是与当前分支合并，则冒号后面的部分可以省略。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git pull origin next
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也就是先做git fetch，再做git merge。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git fetch origin
$ git merge origin/next
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;5-git-add:d71c3921adf591fdd23ac81ec6f69f8c&#34;&gt;5.git add&lt;/h2&gt;

&lt;p&gt;把修改信息添加到index暂存区。
添加所有文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git add -A
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;添加指定文件到暂存区：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git add &amp;lt;文件1&amp;gt; &amp;lt;文件2&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可以指定文件夹：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git add &amp;lt;文件夹&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;删除文件，并且将删除信息也添加到暂存区：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git rm &amp;lt;文件1&amp;gt; &amp;lt;文件2&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重命名，并且将重命名信息也添加到暂存区：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git mv &amp;lt;原文件名&amp;gt; &amp;lt;新文件名&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;6-git-commit:d71c3921adf591fdd23ac81ec6f69f8c&#34;&gt;6.git commit&lt;/h2&gt;

&lt;p&gt;把暂存区的修改，提交到仓库：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git commit -m &amp;quot;信息&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;原则上是，每一个原子修改，都作一次提交。&lt;/p&gt;

&lt;h2 id=&#34;7-git-push:d71c3921adf591fdd23ac81ec6f69f8c&#34;&gt;7.git push&lt;/h2&gt;

&lt;p&gt;将本地分支的更新，推送到远程主机。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git push &amp;lt;远程主机名&amp;gt; &amp;lt;本地分支名&amp;gt;:&amp;lt;远程分支名&amp;gt;   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通常本地分支名和远程分支名都同名，可以省略远程分支名。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git push origin master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;表示将本地的master分支推送到origin主机的master分支。&lt;/p&gt;

&lt;h2 id=&#34;其他:d71c3921adf591fdd23ac81ec6f69f8c&#34;&gt;其他&lt;/h2&gt;

&lt;p&gt;显示暂存区和工作区的差异：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git diff  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;显示有变更的文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git status
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;参考:d71c3921adf591fdd23ac81ec6f69f8c&#34;&gt;参考&lt;/h2&gt;

&lt;p&gt;1.阮一峰  &lt;a href=&#34;http://www.ruanyifeng.com/blog/2014/06/git_remote.html&#34;&gt;Git远程操作详解&lt;/a&gt;&lt;br /&gt;
2.阮一峰  &lt;a href=&#34;http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html?utm_source=tool.lu&#34;&gt;常用 Git 命令清单&lt;/a&gt;&lt;br /&gt;
3.廖雪峰  &lt;a href=&#34;http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000&#34;&gt;Git教程&lt;/a&gt;&lt;br /&gt;
4.&lt;a href=&#34;http://git-scm.com/book/zh/v2&#34;&gt;Git官方文档&lt;/a&gt;&lt;br /&gt;
5.Git常用命令一览&lt;br /&gt;
&lt;img src=&#34;http://7xrjai.com1.z0.glb.clouddn.com/20160306-git-cmd.png&#34; alt=&#34;git-cmd&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>利用hugo搭建个人博客入门教程</title>
      <link>http://youngspring1.github.io/post/2016-03-06-hugo/</link>
      <pubDate>Sun, 06 Mar 2016 10:28:49 +0800</pubDate>
      
      <guid>http://youngspring1.github.io/post/2016-03-06-hugo/</guid>
      <description>

&lt;h3 id=&#34;起因:c4d0ba6a52d2bffd88ff711ada3d2ff1&#34;&gt;起因&lt;/h3&gt;

&lt;p&gt;之前看过腾讯工程师写的《Web全站工程师的自我修养》&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:c4d0ba6a52d2bffd88ff711ada3d2ff1:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:c4d0ba6a52d2bffd88ff711ada3d2ff1:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;一书，萌生了搭建一个博客的想法，用来记录学习记录和生活感受。先用免费的github，挂载静态页面试试吧。原来计划使用道听途说的Jekyll，然后一不小心看到了这篇文章&lt;a href=&#34;http://blog.coderzh.com/2015/08/29/hugo/&#34;&gt;http://blog.coderzh.com/2015/08/29/hugo/&lt;/a&gt;，各种好:&lt;br /&gt;
1.只有一个二进制文件。&lt;br /&gt;
2.可以将宇宙标准MarkDown格式的文章自动转换为静态网页。&lt;br /&gt;
3.内置Web服务器，可以立即在本地查看修改结果。&lt;br /&gt;
那么就用hugo&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:c4d0ba6a52d2bffd88ff711ada3d2ff1:2&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:c4d0ba6a52d2bffd88ff711ada3d2ff1:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;吧。有空再试试hexo&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:c4d0ba6a52d2bffd88ff711ada3d2ff1:3&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:c4d0ba6a52d2bffd88ff711ada3d2ff1:3&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;h3 id=&#34;安装hugo:c4d0ba6a52d2bffd88ff711ada3d2ff1&#34;&gt;安装hugo&lt;/h3&gt;

&lt;p&gt;我是在mac上通过tar压缩文件安装的。&lt;br /&gt;
其他方法可以参考官方文档。&lt;br /&gt;
1.下载&lt;br /&gt;
&amp;emsp;下载地址：&lt;a href=&#34;https://github.com/spf13/hugo/releases&#34;&gt;https://github.com/spf13/hugo/releases&lt;/a&gt;&lt;br /&gt;
&amp;emsp;我要的mac版，文件名长这样：hugo_X.YY_darwin_amd64.zip&lt;br /&gt;
2.解压&lt;br /&gt;
&amp;emsp;解压后是这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls -l   
total 31696
-rw-r--r--@ 1 username  staff     10480  2 28 21:38 LICENSE.md
-rw-r--r--@ 1 username  staff      7694  2 28 21:38 README.md
-rwxr-xr-x@ 1 username  staff  16201084  2 28 21:38 hugo_0.15_darwin_amd64
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;emsp;试一试：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./hugo_0.15_darwin_amd64 version   
Hugo Static Site Generator v0.15 BuildDate: 2016-02-28T21:38:32+08:00   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.创建链接文件&lt;br /&gt;
&amp;emsp;这么长的命令，用起来多不方便啊，我们简化一下。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ln -s /fullpath/fullpath/hugo_0.15_darwin_amd64 hugo
$ ls -l
total 31696
-rw-r--r--@ 1 username  staff     10480  2 28 21:38 LICENSE.md
-rw-r--r--@ 1 username  staff      7694  2 28 21:38 README.md
lrwxr-xr-x  1 username  staff        54  2 28 22:05 hugo -&amp;gt; /fullpath/fullpath/hugo_0.15_darwin_amd64
-rwxr-xr-x@ 1 username  staff  16201084  2 28 21:38 hugo_0.15_darwin_amd64
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;emsp;亲测有效：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./hugo version   
Hugo Static Site Generator v0.15 BuildDate: 2016-02-28T21:38:32+08:00   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4.加入PATH&lt;br /&gt;
&amp;emsp;这还不够，我们要加到PATH里去。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ which hugo
/fullpath/fullpath/hugo
$ vi ~/.bash_profile
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;emsp;加入这一行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export PATH=$PATH:/fullpath/fullpath
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;emsp;这样你应该可以在任意位置运行hugo命令了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo version   
Hugo Static Site Generator v0.15 BuildDate: 2016-02-28T21:38:32+08:00   
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;生成本地站点:c4d0ba6a52d2bffd88ff711ada3d2ff1&#34;&gt;生成本地站点&lt;/h3&gt;

&lt;p&gt;安装好hugo之后，就可以很轻松地生成本地站点啦：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo new site mysite
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;hugo会在当前的目录下，生成mysite这个目录，cd进去，目录结构如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;archetypes/
content/
layouts/
static/
config.toml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中content是MarkDown文章目录，layouts存放的是网站的模版文件，static存放的是图片、css、js资源等。config.toml是网站的配置文件，你也可以换成yaml、json等。&lt;/p&gt;

&lt;h3 id=&#34;创建文章:c4d0ba6a52d2bffd88ff711ada3d2ff1&#34;&gt;创建文章&lt;/h3&gt;

&lt;p&gt;在mysite目录下，创建一个[关于]页面：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd mysite
$ hugo new about.md
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;内容自己填呗。
再创建一个文章页面：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo new post/2016-03-06-first.md
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;内容自己填。&lt;br /&gt;
想看看效果么？等等，还需要导入个主题。&lt;/p&gt;

&lt;h3 id=&#34;导入主题:c4d0ba6a52d2bffd88ff711ada3d2ff1&#34;&gt;导入主题&lt;/h3&gt;

&lt;p&gt;还是在在mysite目录下，创建一个文件夹，我们随便clone一个主题下来。&lt;br /&gt;
我在&lt;a href=&#34;https://themes.gohugo.io&#34;&gt;https://themes.gohugo.io&lt;/a&gt;上没有找到喜欢的主题，就直接拉了上面原文作者的主题。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mkdir themes
$ cd themes
$ git clone https://github.com/coderzh/hugo-rapid-theme.git
$ cd ..
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;（主题里面包含了作者的信息，如果需要使用，记得修改。）&lt;/p&gt;

&lt;h3 id=&#34;调试:c4d0ba6a52d2bffd88ff711ada3d2ff1&#34;&gt;调试&lt;/h3&gt;

&lt;p&gt;现在终于可以调试了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo server --theme=hugo-rapid-theme --buildDrafts --watch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;浏览器里打开：&lt;a href=&#34;http://localhost:1313&#34;&gt;http://localhost:1313&lt;/a&gt;&lt;br /&gt;
选项watch会让服务器自动检测文章的改动，自动刷新浏览器，非常方便。&lt;/p&gt;

&lt;h3 id=&#34;发布:c4d0ba6a52d2bffd88ff711ada3d2ff1&#34;&gt;发布&lt;/h3&gt;

&lt;p&gt;在本地自己偷着看有什么意思，发布到github上去吧。&lt;br /&gt;
1.生成静态页面&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo --theme=hugo-rapid-theme --buildDrafts --baseUrl=&amp;quot;http://youngspring1.github.io&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;emsp;这里的url要替换成你自己的。&lt;br /&gt;
&amp;emsp;所有的静态页面都会生成到public目录。&lt;/p&gt;

&lt;p&gt;2.创建Repository&lt;br /&gt;
&amp;emsp;在github上创建一个Repository，名为&amp;rdquo;youngspring1.github.io&amp;rdquo;。&lt;br /&gt;
&amp;emsp;同样，不认识的名字要替换成你自己的。&lt;/p&gt;

&lt;p&gt;3.提交&lt;br /&gt;
&amp;emsp;把public目录下的内容，全部提交到刚刚创建的Repository中。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd public
$ git init
$ git remote add origin https://github.com/youngspring1/youngspring1.github.io.git
$ git add -A
$ git commit -m &amp;quot;first commit&amp;quot;
$ git push -u origin master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;emsp;在浏览器中访问&lt;a href=&#34;http://youngspring1.github.io&#34;&gt;http://youngspring1.github.io&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;参考:c4d0ba6a52d2bffd88ff711ada3d2ff1&#34;&gt;参考&lt;/h3&gt;

&lt;p&gt;原文作者&lt;a href=&#34;http://blog.coderzh.com&#34;&gt;coderzh&lt;/a&gt;搭建的中文的hugo站点：&lt;a href=&#34;http://www.gohugo.org/&#34;&gt;http://www.gohugo.org/&lt;/a&gt;&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:c4d0ba6a52d2bffd88ff711ada3d2ff1:1&#34;&gt;余果：&lt;a href=&#34;http://www.amazon.cn/Web全栈工程师的自我修养-余果/dp/B0141BI0D2/ref=sr_1_1?s=books&amp;amp;ie=UTF8&amp;amp;qid=1457233956&amp;amp;sr=1-1&#34;&gt;《Web全站工程师的自我修养》&lt;/a&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:c4d0ba6a52d2bffd88ff711ada3d2ff1:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:c4d0ba6a52d2bffd88ff711ada3d2ff1:2&#34;&gt;hugo主页：&lt;a href=&#34;https://gohugo.io&#34;&gt;https://gohugo.io&lt;/a&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:c4d0ba6a52d2bffd88ff711ada3d2ff1:2&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:c4d0ba6a52d2bffd88ff711ada3d2ff1:3&#34;&gt;hexo主页：&lt;a href=&#34;https://www.hexo.io&#34;&gt;https://www.hexo.io&lt;/a&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:c4d0ba6a52d2bffd88ff711ada3d2ff1:3&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>